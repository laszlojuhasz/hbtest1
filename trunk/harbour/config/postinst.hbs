/*
 * $Id$
 */

/*
 * This Harbour script is part of the GNU Make-based build system.
 * WARNING: Running it separately is not supported.
 *
 * Copyright 2009-2010 Viktor Szakats (harbour.01 syenar.hu)
 * Copyright 2003 Przemyslaw Czerpak (druzus/at/priv.onet.pl) (embedded autoinstall bash script)
 * See COPYING for licensing terms.
 */

#pragma warninglevel=3
#pragma -km+
#pragma -ko+

/* TOFIX: Ugly hack to avoid #include "directry.ch" */
#define F_NAME                1              /* File name */
#define F_ATTR                5              /* File attribute */

/* POSIX file permission */
#define HB_FA_SUID            0x08000000     /* 4000 set user ID on execution */
#define HB_FA_SGID            0x04000000     /* 2000 set group ID on execution */
#define HB_FA_SVTX            0x02000000     /* 1000 sticky bit */
#define HB_FA_RUSR            0x01000000     /* 0400 read by owner */
#define HB_FA_WUSR            0x00800000     /* 0200 write by owner */
#define HB_FA_XUSR            0x00400000     /* 0100 execute/search by owner */
#define HB_FA_RGRP            0x00200000     /* 0040 read by group */
#define HB_FA_WGRP            0x00100000     /* 0020 write by group */
#define HB_FA_XGRP            0x00080000     /* 0010 execute/search by group */
#define HB_FA_ROTH            0x00040000     /* 0004 read by others */
#define HB_FA_WOTH            0x00020000     /* 0002 write by others */
#define HB_FA_XOTH            0x00010000     /* 0001 execute/search by others */

PROCEDURE Main( ... )
   LOCAL nErrorLevel := 0
   LOCAL aFile

   LOCAL tmp
   LOCAL cOldDir

   LOCAL cTar_Name
   LOCAL cTar_NameExt
   LOCAL cTar_Path
   LOCAL cBin_Tar
   LOCAL lGNU_Tar
   LOCAL cOwner
   LOCAL cGroup
   LOCAL cSH_Script
   LOCAL nAttr

   IF Empty( GetEnv( "HB_PLATFORM" ) ) .OR. ;
      Empty( GetEnv( "HB_COMPILER" ) ) .OR. ;
      Empty( GetEnv( "HB_HOST_BIN_DIR" ) )

      OutStd( "! Error: This program has to be called from the GNU Make process." + hb_eol() )
      ErrorLevel( 1 )
      RETURN
   ENDIF

   /* Detect install build phase */

   IF AScan( hb_AParams(), {| tmp | Lower( tmp ) == "install" } ) > 0

      /* Installing some misc files */

      IF GetEnv( "HB_PLATFORM" ) $ "win|wce|os2|dos"
         tmp := GetEnv( "HB_INSTALL_PREFIX" )
      ELSE
         tmp := GetEnv( "HB_INSTALL_DOC" )
      ENDIF
      IF ! Empty( tmp )

         OutStd( "! Copying root documents..." + hb_eol() )

         FOR EACH aFile IN Directory( "Change*" )
            mk_hb_FCopy( aFile[ F_NAME ], tmp + hb_ps() + iif( GetEnv( "HB_PLATFORM" ) == "dos", "CHANGES", "" ) )
         NEXT

         mk_hb_FCopy( "COPYING", tmp + hb_ps() )
         mk_hb_FCopy( "INSTALL", tmp + hb_ps() )
         mk_hb_FCopy( "NEWS"   , tmp + hb_ps() )
         mk_hb_FCopy( "TODO"   , tmp + hb_ps() )
      ENDIF

      IF ! Empty( GetEnv( "HB_INSTALL_BIN" ) )

         OutStd( "! Copying Harbour script (.hbs) files..." + hb_eol() )

         /* public Harbour scripts */
         FOR EACH tmp IN { "bin/hbmk2l2d.hbs" ,;
                           "bin/hbxpatch.hbs" }
            mk_hb_FCopy( tmp, GetEnv( "HB_INSTALL_BIN" ) + hb_ps() )
         NEXT
      ENDIF

      IF ! Empty( GetEnv( "HB_INSTALL_ETC" ) )

         OutStd( "! Copying *nix config files..." + hb_eol() )

         IF DirBuild( GetEnv( "HB_INSTALL_ETC" ) )
            mk_hb_FCopy( "src/rtl/gtcrs/hb-charmap.def", GetEnv( "HB_INSTALL_ETC" ) + hb_ps(), .T. )
         ELSE
            OutStd( hb_StrFormat( "! Error: Cannot create directory '%1$s'", GetEnv( "HB_INSTALL_ETC" ) ) + hb_eol() )
         ENDIF

         IF ! Empty( GetEnv( "HB_INSTALL_LIB" ) )

            OutStd( "! Creating *nix ld config file..." + hb_eol() )

            tmp := GetEnv( "HB_INSTALL_ETC" ) + hb_ps() + ".." + hb_ps() + "ld.so.conf.d"
            IF DirBuild( tmp )
               /* TOFIX: Put HB_INSTALL_LIB without build sandbox prefix */
               hb_MemoWrit( tmp + hb_ps() + "harbour.conf", GetEnv( "HB_INSTALL_LIB" ) + hb_eol() )
            ELSE
               OutStd( hb_StrFormat( "! Error: Cannot create directory '%1$s'", tmp ) + hb_eol() )
            ENDIF
         ENDIF
      ENDIF

      IF ! Empty( GetEnv( "HB_INSTALL_MAN" ) )

         OutStd( "! Copying *nix man files..." + hb_eol() )

         IF DirBuild( GetEnv( "HB_INSTALL_MAN" ) + hb_ps() + "man1" )
            FOR EACH tmp IN { "src/main/harbour.1"    ,;
                              "src/pp/hbpp.1"         ,;
                              "utils/hbmk2/hbmk2.1"   ,;
                              "utils/hbrun/hbrun.1"   ,;
                              "utils/hbtest/hbtest.1" }
               mk_hb_FCopy( tmp, GetEnv( "HB_INSTALL_MAN" ) + hb_ps() + "man1" + hb_ps(), .T. )
            NEXT
         ELSE
            OutStd( hb_StrFormat( "! Error: Cannot create directory '%1$s'", GetEnv( "HB_INSTALL_MAN" ) ) + hb_eol() )
         ENDIF
      ENDIF

      /* TOFIX: Rewrite this in .prg */
      #if 0
      FOR EACH tmp IN { GetEnv( "HB_DYNLIB_ST" ), GetEnv( "HB_DYNLIB_MT" ) }

         OutStd( GetEnv( "HB_INSTALL_DYN" + hb_ps() + tmp + hb_eol() )

            ll="` echo $l | sed 's!'${lib_suff}'$!!' `${lib_ext}"
            ln -sf $l $ll

            IF !( GetEnv( "HB_PLATFORM" ) $ "win|wce" )
               DO CASE
               CASE GetEnv( "HB_INSTALL_LIB" ) $ "/usr/lib/harbour|/usr/lib64/harbour|/usr/local/lib/harbour|/usr/local/lib64/harbour"
                     ln -sf harbour/$l ../$ll
                     ln -sf harbour/$l ../$l
                     ;;
               CASE GetEnv( "HB_INSTALL_LIB" ) $ "/usr/local/harbour/lib"
                     ld="/usr/lib"
                     if [ -n "${HB_INST_PKGPREF}" ] || [ -w $ld ]
                     then
                        mkdir -p ${HB_INST_PKGPREF}$ld
                        ln -sf ../local/harbour/lib/$l ${HB_INST_PKGPREF}$ld/$ll
                        ln -sf ../local/harbour/lib/$l ${HB_INST_PKGPREF}$ld/$l
                     fi
                     ;;
                  *)
                     ;;
               ENDCASE
            ENDIF
         fi
      done
      #endif

      /* Creating language files */

      IF ! Empty( GetEnv( "HB_INSTALL_BIN" ) )

         OutStd( "! Making core translation (.hbl) files..." + hb_eol() )

         FOR EACH tmp IN Directory( "utils" + hb_ps() + hb_osFileMask(), "D" )
            IF "D" $ tmp[ F_ATTR ] .AND. !( tmp[ F_NAME ] == "." ) .AND. !( tmp[ F_NAME ] == ".." )
               FOR EACH aFile IN Directory( "utils" + hb_ps() + tmp[ F_NAME ] + hb_ps() + "*.po" )
                  mk_hbl( "utils" + hb_ps() + tmp[ F_NAME ] + hb_ps() + aFile[ F_NAME ],;
                          PathSepToSelf( GetEnv( "HB_INSTALL_BIN" ) ) + hb_ps() + FNameExtSet( aFile[ F_NAME ], ".hbl" ) )
               NEXT
            ENDIF
         NEXT
      ENDIF

      /* Creating docs for core */

      IF ! Empty( GetEnv( "HB_INSTALL_DOC" ) )

         OutStd( "! Compiling core documentation (.hbd)..." + hb_eol() )

         mk_hbd_core( "." + hb_ps(), GetEnv( "HB_INSTALL_DOC" ) )
      ENDIF

      /* Creating install packages */

      IF GetEnv( "HB_BUILD_PKG" ) == "yes" .AND. ;
         ! Empty( GetEnv( "HB_TOP" ) )

         IF GetEnv( "HB_PLATFORM" ) $ "win|wce|os2|dos"

            tmp := GetEnv( "HB_TOP" ) + hb_ps() + GetEnv( "HB_PKGNAME" ) + ".zip"

            OutStd( "! Making Harbour .zip install package: '" + tmp + "'" + hb_eol() )

            FErase( tmp )

            /* NOTE: Believe it or not this is the official method to zip a different dir with subdirs
                     without including the whole root path in filenames; you have to 'cd' into it.
                     Even with zip 3.0. For this reason we need absolute path in HB_TOP. There is also
                     no zip 2.x compatible way to force creation of a new .zip, so we have to delete it
                     first to avoid mixing in an existing .zip file. [vszakats] */

            cOldDir := hb_ps() + CurDir()
            DirChange( GetEnv( "HB_INSTALL_PKG_TOP" ) )

            mk_hb_processRun( PathSepToSelf( GetEnv( "HB_DIR_ZIP" ) ) + "zip" +;
                              " -q -9 -X -r -o" +;
                              " " + FNameEscape( tmp ) +;
                              " . -i " + FNameEscape( GetEnv( "HB_PKGNAME" ) + hb_ps() + "*" ) +;
                              " -x *.tds -x *.exp" )

            DirChange( cOldDir )

            IF GetEnv( "HB_PLATFORM" ) $ "win|wce"

               tmp := GetEnv( "HB_TOP" ) + hb_ps() + GetEnv( "HB_PKGNAME" ) + ".exe"

               OutStd( "! Making Harbour .exe install package: '" + tmp + "'" + hb_eol() )

               mk_hb_processRun( PathSepToSelf( GetEnv( "HB_DIR_NSIS" ) ) + "makensis.exe" +;
                                 " -V2" +;
                                 " " + FNameEscape( StrTran( "package/mpkg_win.nsi", "/", hb_ps() ) ) )
            ENDIF
         ELSE
            cBin_Tar := "tar"
            lGNU_Tar := .T.
            IF ! Empty( query_stdout( "gtar --version" ) )
               cBin_Tar := "gtar"
            ELSEIF Empty( query_stdout( "tar --version" ) )
               cBin_Tar := ""
            ELSEIF "bsdtar" $ query_stdout( "tar --version" )
               /* tar is mapped to bsdtar starting OS X 10.6 */
               lGNU_Tar := .F.
            ENDIF

            IF ! Empty( cBin_Tar )

               cTar_Name := GetEnv( "HB_PKGNAME" )
               IF ! Empty( tmp := unix_name() )
                  cTar_Name += "-" + tmp
               ENDIF
               cTar_NameExt := cTar_Name + iif( GetEnv( "HB_PLATFORM" ) == "dos", ".tgz", ".bin.tar.gz" )
               cTar_Path := GetEnv( "HB_TOP" ) + hb_ps() + cTar_NameExt

               OutStd( "! Making Harbour tar install package: '" + cTar_Path + "'" + hb_eol() )

               FErase( cTar_Path )

               cOwner := "root"
               cGroup := iif( GetEnv( "HB_PLATFORM" ) == "darwin" .OR. ;
                              GetEnv( "HB_PLATFORM" ) == "bsd", "wheel", "root" )

               cOldDir := hb_ps() + CurDir()
               DirChange( GetEnv( "HB_INSTALL_PKG_TOP" ) )

               /* TODO: Add support for non-GNU non-BSD tar (which gets the data from stdio) */

               mk_hb_processRun( cBin_Tar +;
                                 " czvf" +;
                                 " " + FNameEscape( cTar_Path ) +;
                                 iif( lGNU_Tar, " --owner=" + cOwner + " --group=" + cGroup, "" ) +;
                                 " ." )

               DirChange( cOldDir )

               IF !( GetEnv( "HB_PLATFORM" ) == "dos" )

                  tmp := GetEnv( "HB_TOP" ) + hb_ps() + cTar_Name + ".inst.sh"

                  OutStd( "! Making Harbour tar installer package: '" + tmp + "'" + hb_eol() )

                  /* In the generated script always use tar because we can't be sure
                     if cBin_Tar exists in the installation environment */
                  cSH_Script := '#!/bin/sh' + Chr( 10 )
                  cSH_Script += 'if [ "\$1" = "--extract" ]; then' + Chr( 10 )
                  cSH_Script += '   tail -c ' + hb_ntos( hb_FSize( cTar_Path ) ) + ' "\$0" > "' + cTar_NameExt + '"' + Chr( 10 )
                  cSH_Script += '   exit' + Chr( 10 )
                  cSH_Script += 'fi' + Chr( 10 )
                  cSH_Script += 'if [ \`id -u\` != 0 ]; then' + Chr( 10 )
                  cSH_Script += '   echo "This package has to be installed from root account."' + Chr( 10 )
                  cSH_Script += '   exit 1' + Chr( 10 )
                  cSH_Script += 'fi' + Chr( 10 )
                  cSH_Script += 'echo "Do you want to install Harbour (y/n)"' + Chr( 10 )
                  cSH_Script += 'read ASK' + Chr( 10 )
                  cSH_Script += 'if [ "\${ASK}" != "y" ] && [ "\${ASK}" != "Y" ]; then' + Chr( 10 )
                  cSH_Script += '   exit 1' + Chr( 10 )
                  cSH_Script += 'fi' + Chr( 10 )
                  cSH_Script += '(tail -c ' + hb_ntos( hb_FSize( cTar_Path ) ) + ' "\$0" | gzip -cd | (cd /;tar xvpf -)) ' + iif( GetEnv( "HB_PLATFORM" ) == "linux", "&& ldconfig", "" ) + Chr( 10 )
                  cSH_Script += 'exit \$?' + Chr( 10 )
                  cSH_Script += 'HB_INST_EOF' + Chr( 10 )

                  hb_MemoWrit( tmp, cSH_Script + hb_MemoRead( cTar_Path ) )

                  hb_FGetAttr( tmp, @nAttr )
                  hb_FSetAttr( tmp, hb_bitOr( nAttr, HB_FA_XOTH ) )
               ENDIF
            ELSE
               OutStd( "! Error: Cannot find 'tar' tool" + hb_eol() )
            ENDIF
         ENDIF
      ENDIF
   ELSE
      /* Regenerating extern headers */

      mk_extern_core()
   ENDIF

   ErrorLevel( nErrorLevel )

   RETURN

STATIC FUNCTION mk_hbl( cIn, cOut )
   LOCAL cErrorMsg
   LOCAL aTrans

   aTrans := __i18n_potArrayLoad( cIn, @cErrorMsg )
   IF aTrans != NIL
      IF hb_MemoWrit( cOut, hb_i18n_SaveTable( __i18n_hashTable( __i18n_potArrayToHash( aTrans, .F. ) ) ) )
         OutStd( "! Created " + cOut + " <= " + cIn + hb_eol() )
         RETURN .T.
      ELSE
         OutErr( "! Error: Cannot create file: " + cOut + hb_eol() )
      ENDIF
   ELSE
      OutErr( "! Error: Loading translation: " + cIn + " (" + cErrorMsg + ")" + hb_eol() )
   ENDIF

   RETURN .F.

STATIC FUNCTION mk_hbd_core( cDirSource, cDirDest )
   LOCAL cName := "harbour"
   LOCAL tmp

   LOCAL aErrMsg := {}
   LOCAL aEntry := __hbdoc_LoadDir( cDirSource, cName, aErrMsg )

   FOR EACH tmp IN aErrMsg
      OutErr( hb_StrFormat( "! %1$s", tmp ) + hb_eol() )
   NEXT

   IF ! Empty( aEntry )
      cName := PathSepToSelf( cDirDest ) + hb_ps() + cName + ".hbd"
      IF __hbdoc_SaveHBD( cName, aEntry )
         OutStd( "! Created " + cName + " <= " + cDirSource + hb_eol() )
         RETURN .T.
      ELSE
         OutErr( hb_StrFormat( "! Error: Saving '%1$s'", cName ) + hb_eol() )
      ENDIF
   ENDIF

   RETURN .F.

STATIC FUNCTION mk_hb_processRun( cCommand, ... )

   OutStd( cCommand + hb_eol() )

   RETURN hb_processRun( cCommand, ... )

STATIC FUNCTION FNameEscape( cFN )
   RETURN Chr( 34 ) + cFN + Chr( 34 )

STATIC FUNCTION FNameExtSet( cFileName, cExt )
   LOCAL cDir, cName

   hb_FNameSplit( cFileName, @cDir, @cName )

   RETURN hb_FNameMerge( cDir, cName, cExt )

STATIC FUNCTION PathSepToSelf( cFileName )
   RETURN StrTran( cFileName, iif( hb_ps() == "\", "/", "\" ), hb_ps() )

STATIC FUNCTION DirBuild( cDir )
   LOCAL cDirTemp
   LOCAL cDirItem
   LOCAL tmp

   cDir := PathNormalize( PathSepToSelf( cDir ) )

   IF ! hb_DirExists( cDir )

      cDir := DirAddPathSep( cDir )

      IF ! Empty( hb_osDriveSeparator() ) .AND. ;
         ( tmp := At( hb_osDriveSeparator(), cDir ) ) > 0
         cDirTemp := Left( cDir, tmp )
         cDir := SubStr( cDir, tmp + 1 )
      ELSEIF Left( cDir, 1 ) == hb_ps()
         cDirTemp := Left( cDir, 1 )
         cDir := SubStr( cDir, 2 )
      ELSE
         cDirTemp := ""
      ENDIF

      FOR EACH cDirItem IN hb_ATokens( cDir, hb_ps() )
         IF !( Right( cDirTemp, 1 ) == hb_ps() ) .AND. ! Empty( cDirTemp )
            cDirTemp += hb_ps()
         ENDIF
         IF ! Empty( cDirItem )  /* Skip root path, if any */
            cDirTemp += cDirItem
            IF hb_FileExists( cDirTemp )
               RETURN .F.
            ELSEIF ! hb_DirExists( cDirTemp )
               IF MakeDir( cDirTemp ) != 0
                  RETURN .F.
               ENDIF
            ENDIF
         ENDIF
      NEXT
   ENDIF

   RETURN .T.

#define _ISDRIVESPEC( cDir ) ( ! Empty( hb_osDriveSeparator() ) .AND. Right( cDir, Len( hb_osDriveSeparator() ) ) == hb_osDriveSeparator() )

/* NOTE: Can hurt if there are symlinks on the way. */
STATIC FUNCTION PathNormalize( cPath )
   LOCAL aDir
   LOCAL cDir

   IF ! Empty( cPath )

      aDir := hb_ATokens( cPath, hb_ps() )

      FOR EACH cDir IN aDir DESCEND
         IF cDir == "."
            hb_ADel( aDir, cDir:__enumIndex(), .T. )
         ELSEIF !( cDir == ".." ) .AND. ;
            ! Empty( cDir ) .AND. ;
            ! _ISDRIVESPEC( cDir )
            IF cDir:__enumIndex() < Len( cDir:__enumBase() ) .AND. ;
               aDir[ cDir:__enumIndex() + 1 ] == ".."
               hb_ADel( aDir, cDir:__enumIndex() + 1, .T. )
               hb_ADel( aDir, cDir:__enumIndex(), .T. )
            ENDIF
         ENDIF
      NEXT

      cPath := ""
      FOR EACH cDir IN aDir
         cPath += cDir
         IF cDir:__enumIndex() < Len( cDir:__enumBase() )
            cPath += hb_ps()
         ENDIF
      NEXT

      IF Empty( cPath )
         cPath := "." + hb_ps()
      ENDIF
   ENDIF

   RETURN cPath

STATIC FUNCTION DirAddPathSep( cDir )

   IF ! Empty( cDir ) .AND. !( Right( cDir, 1 ) == hb_ps() )
      cDir += hb_ps()
   ENDIF

   RETURN cDir

/* Like hb_FCopy(), but accepts dir as target and can set attributes */
STATIC PROCEDURE mk_hb_FCopy( cSrc, cDst, l644 )
   LOCAL cDir, cName, cExt

   IF ! hb_isLogical( l644 )
      l644 := .F.
   ENDIF

   cSrc := PathSepToSelf( cSrc )
   cDst := PathSepToSelf( cDst )

   hb_FNameSplit( cDst, @cDir, @cName, @cExt )
   IF Empty( cName ) .AND. Empty( cExt )
      hb_FNameSplit( cSrc,, @cName, @cExt )
   ENDIF
   cDst := hb_FNameMerge( cDir, cName, cExt )

   IF hb_FCopy( cSrc, cDst ) == 0
#if 0
      OutStd( hb_StrFormat( "! Copied: %1$s <= %2$s", cDst, cSrc ) + hb_eol() )
#endif
      IF l644
         hb_FSetAttr( cDst, hb_bitOr( HB_FA_RUSR, HB_FA_WUSR, HB_FA_RGRP, HB_FA_ROTH ) )
      ENDIF
#if 0
   ELSE
      OutStd( hb_StrFormat( "! Error: Copying %1$s <= %2$s", cDst, cSrc ) + hb_eol() )
#endif
   ENDIF

   RETURN

STATIC FUNCTION query_stdout( cName )
   LOCAL cStdOut
   LOCAL cStdErr
   LOCAL nRetVal

   nRetVal := hb_processRun( cName,, @cStdOut, @cStdErr )

   RETURN iif( nRetVal == 0, AllTrim( StrTran( cStdOut, Chr( 10 ), " " ) ), "" )

STATIC FUNCTION query_rpm( cName, cID )
   LOCAL cResult := query_stdout( "rpm -q --queryformat='.%{VERSION}' " + cName )

   RETURN iif( Empty( cResult ), "", cID + AllTrim( StrTran( StrTran( cResult, Chr( 10 ), " " ), "." ) ) )

/* Please add your distro suffix if it not belong to the one recognized below
   and remember that order checking can be important */
STATIC FUNCTION unix_name()
   LOCAL tmp

   DO CASE
   CASE GetEnv( "HB_PLATFORM" ) == "dos" ; RETURN "djgpp"
   CASE GetEnv( "HB_PLATFORM" ) == "win" ; RETURN GetEnv( "HB_COMPILER" )
   CASE ! Empty( tmp := query_rpm( "mandriva-release-One", "mdv" ) ) ; RETURN tmp
   CASE ! Empty( tmp := query_rpm( "mandriva-release"    , "mdv" ) ) ; RETURN tmp
   CASE ! Empty( tmp := query_rpm( "redhat-release"      , "rh"  ) ) ; RETURN tmp
   CASE ! Empty( tmp := query_rpm( "fedora-release"      , "fc"  ) ) ; RETURN tmp
   CASE ! Empty( tmp := query_rpm( "suse-release"        , "sus" ) ) ; RETURN tmp
   CASE ! Empty( tmp := query_rpm( "openSUSE-release"    , "sus" ) ) ; RETURN tmp
   /* TODO: Rewrite this in Harbour */
   CASE hb_FileExists( "/etc/pld-release" )
      RETURN "" /* cat /etc/pld-release|sed -e '/1/ !d' -e 's/[^0-9]//g' -e 's/^/pld/'` */
   ENDCASE

   RETURN StrTran( Lower( query_stdout( "uname -s" ) ), " ", "_" )

STATIC FUNCTION mk_extern_core()
   LOCAL aExtern

   IF GetEnv( "HB_REBUILD_EXTERN" ) == "yes" .AND. ;
      ! Empty( GetEnv( "HB_DYNLIB_ST" ) )

      OutStd( "! Generating core extern headers..." + hb_eol() )

      IF ( aExtern := __hb_extern_get_list( GetEnv( "HB_DYNLIB_DIR" ) + hb_ps() + GetEnv( "HB_DYNLIB_ST" ) + GetEnv( "HB_DYNLIB_EXT" ) ) ) != NIL

         __hb_extern_gen( aExtern, "include" + hb_ps() + "hbextsca.ch" )
         __hb_extern_gen( aExtern, "include" + hb_ps() + "hbextcdp.ch" )
         __hb_extern_gen( aExtern, "include" + hb_ps() + "hbextlng.ch" )
         __hb_extern_gen( aExtern, "include" + hb_ps() + "hbextudd.ch" )
         __hb_extern_gen( aExtern, "include" + hb_ps() + "hbextern.ch" )

         RETURN .T.
      ENDIF
   ENDIF

   RETURN .F.

#include "hbextern.hbs"
