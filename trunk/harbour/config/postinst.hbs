/*
 * $Id$
 */

/*
 * This Harbour script is part of the GNU Make-based build system.
 * WARNING: Running it separately is not supported.
 *
 * Copyright 2009-2010 Viktor Szakats (harbour.01 syenar.hu)
 * See COPYING for licensing terms.
 */

#pragma warninglevel=3

/* TOFIX: Ugly hack to avoid #include "directry.ch" */
#define F_NAME          1       /* File name */
#define F_ATTR          5       /* File attribute */

PROCEDURE Main()
   LOCAL nErrorLevel := 0
   LOCAL aDir
   LOCAL aFile

   LOCAL tmp
   LOCAL cOldDir

   IF Empty( GetEnv( "HB_PLATFORM" ) ) .OR. ;
      Empty( GetEnv( "HB_COMPILER" ) ) .OR. ;
      Empty( GetEnv( "HB_BIN_INSTALL" ) ) .OR. ;
      Empty( GetEnv( "HB_LIB_INSTALL" ) ) .OR. ;
      Empty( GetEnv( "HB_INC_INSTALL" ) )

      OutStd( "! Error: This program has to be called from the GNU Make process." + hb_eol() )
      ErrorLevel( 1 )
      RETURN
   ENDIF

   /* Installing some misc files */

   IF GetEnv( "HB_PLATFORM" ) $ "win|wce|os2|dos" .AND. ;
      ! Empty( GetEnv( "HB_INSTALL_PREFIX" ) )

      OutStd( "! Copying root documents..." + hb_eol() )

      FOR EACH aFile IN Directory( "Change*" )
         hb_FCopy( aFile[ F_NAME ], GetEnv( "HB_INSTALL_PREFIX" ) + hb_ps() + iif( GetEnv( "HB_PLATFORM" ) == "dos", "CHANGES", aFile[ F_NAME ] ) )
      NEXT

      hb_FCopy( "COPYING", GetEnv( "HB_INSTALL_PREFIX" ) + hb_ps() + "COPYING" )
      hb_FCopy( "INSTALL", GetEnv( "HB_INSTALL_PREFIX" ) + hb_ps() + "INSTALL" )
      hb_FCopy( "TODO"   , GetEnv( "HB_INSTALL_PREFIX" ) + hb_ps() + "TODO" )

      /* public Harbour scripts */
      FOR EACH tmp IN { "hbxpatch.hbs" }
         hb_FCopy( "bin" + hb_ps() + tmp, GetEnv( "HB_BIN_INSTALL" ) + hb_ps() + tmp )
      NEXT
   ENDIF

   /* Creating language files */

   OutStd( "! Making translation (.hbl) files..." + hb_eol() )

   FOR EACH tmp IN Directory( "utils" + hb_ps() + hb_osFileMask(), "D" )
      IF "D" $ tmp[ F_ATTR ] .AND. !( tmp[ F_NAME ] == "." ) .AND. !( tmp[ F_NAME ] == ".." )
         FOR EACH aFile IN Directory( "utils" + hb_ps() + tmp[ F_NAME ] + hb_ps() + "*.po" )
            mk_hbl( "utils" + hb_ps() + tmp[ F_NAME ] + hb_ps() + aFile[ F_NAME ],;
                    PathSepToSelf( GetEnv( "HB_BIN_INSTALL" ) ) + hb_ps() + FNameExtSet( aFile[ F_NAME ], ".hbl" ) )
         NEXT
      ENDIF
   NEXT

   /* Creating docs */

   IF ! Empty( GetEnv( "HB_DOC_INSTALL" ) )

      OutStd( "! Making documentation (.hbd) files..." + hb_eol() )

      aDir := { "." + hb_ps() }

      FOR EACH aFile IN Directory( "contrib" + hb_ps() + hb_osFileMask(), "D" )
         IF "D" $ aFile[ F_ATTR ] .AND. ;
            !( aFile[ F_NAME ] == "." ) .AND. ;
            !( aFile[ F_NAME ] == ".." )
            AAdd( aDir, "contrib" + hb_ps() + aFile[ F_NAME ] )
         ENDIF
      NEXT

      FOR EACH tmp IN aDir
         mk_hbd( tmp )
      NEXT
   ENDIF

   /* Creating install packages */

   IF GetEnv( "HB_PLATFORM" ) $ "win|wce|os2|dos" .AND. ;
      GetEnv( "HB_BUILD_PKG" ) == "yes" .AND. ;
      ! Empty( GetEnv( "HB_TOP" ) )

      tmp := GetEnv( "HB_TOP" ) + hb_ps() + GetEnv( "HB_PKGNAME" ) + ".zip"

      OutStd( "! Making Harbour .zip install package: '" + tmp + "'" + hb_eol() )

      FErase( tmp )

      /* NOTE: Believe it or not this is the official method to zip a different dir with subdirs
               without including the whole root path in filenames; you have to 'cd' into it.
               Even with zip 3.0. For this reason we need absolute path in HB_TOP. There is also
               no zip 2.x compatible way to force creation of a new .zip, so we have to delete it
               first to avoid mixing in an existing .zip file. [vszakats] */

      cOldDir := hb_ps() + CurDir()
      DirChange( GetEnv( "HB_INSTALL_PREFIX" ) + hb_ps() + ".." )

      mk_hb_processRun( PathSepToSelf( GetEnv( "HB_DIR_ZIP" ) ) + "zip" +;
                        " -q -9 -X -r -o" +;
                        " " + FNameEscape( tmp ) +;
                        " . -i " + FNameEscape( GetEnv( "HB_PKGNAME" ) + hb_ps() + "*" ) +;
                        " -x *.tds -x *.exp" )

      DirChange( cOldDir )

      IF GetEnv( "HB_PLATFORM" ) $ "win|wce"

         tmp := GetEnv( "HB_TOP" ) + hb_ps() + GetEnv( "HB_PKGNAME" ) + ".exe"

         OutStd( "! Making Harbour .exe install package: '" + tmp + "'" + hb_eol() )

         mk_hb_processRun( PathSepToSelf( GetEnv( "HB_DIR_NSIS" ) ) + "makensis.exe" +;
                           " -V2" +;
                           " " + FNameEscape( StrTran( "package/mpkg_win.nsi", "/", hb_ps() ) ) )
      ENDIF
   ENDIF

   ErrorLevel( nErrorLevel )

   RETURN

STATIC FUNCTION mk_hbl( cIn, cOut )
   LOCAL cErrorMsg
   LOCAL aTrans

   aTrans := __i18n_potArrayLoad( cIn, @cErrorMsg )
   IF aTrans != NIL
      IF hb_MemoWrit( cOut, hb_i18n_SaveTable( __i18n_hashTable( __i18n_potArrayToHash( aTrans, .F. ) ) ) )
         OutStd( "! Created " + cOut + " <= " + cIn + hb_eol() )
         RETURN .T.
      ELSE
         OutErr( "! Error: Cannot create file: " + cOut + hb_eol() )
      ENDIF
   ELSE
      OutErr( "! Error: Loading translation: " + cIn + " (" + cErrorMsg + ")" + hb_eol() )
   ENDIF

   RETURN .F.

STATIC FUNCTION mk_hbd( cDir )
   LOCAL cName
   LOCAL tmp

   LOCAL aErrMsg
   LOCAL aEntry

   cName := DirGetName( cDir )
   IF Empty( cName )
      cName := "harbour"
   ENDIF

   aErrMsg := {}
   aEntry := __hbdoc_LoadDir( cDir, cName, aErrMsg )

   FOR EACH tmp IN aErrMsg
      OutErr( hb_StrFormat( "! %1$s", tmp ) + hb_eol() )
   NEXT

   IF ! Empty( aEntry )
      cName := PathSepToSelf( GetEnv( "HB_DOC_INSTALL" ) ) + hb_ps() + cName + ".hbd"
      IF __hbdoc_SaveHBD( cName, aEntry )
         OutStd( "! Created " + cName + " <= " + cDir + hb_eol() )
         RETURN .T.
      ELSE
         OutErr( hb_StrFormat( "! Error: Saving '%1$s'", cName ) + hb_eol() )
      ENDIF
   ENDIF

   RETURN .F.

STATIC FUNCTION mk_hb_processRun( cCommand )

   OutStd( cCommand + hb_eol() )

   RETURN hb_processRun( cCommand )

STATIC FUNCTION FNameEscape( cFN )
   RETURN Chr( 34 ) + cFN + Chr( 34 )

STATIC FUNCTION FNameExtSet( cFileName, cExt )
   LOCAL cDir, cName

   hb_FNameSplit( cFileName, @cDir, @cName )

   RETURN hb_FNameMerge( cDir, cName, cExt )

STATIC FUNCTION DirGetName( cDir )
   LOCAL cName

   cDir := DirDelPathSep( cDir )

   hb_FNameSplit( cDir,, @cName )

   IF Empty( cName ) .OR. cName == "." .OR. cName == ".."
      RETURN ""
   ENDIF

   RETURN cName

STATIC FUNCTION DirDelPathSep( cDir )

   IF Empty( hb_osDriveSeparator() )
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps()
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ELSE
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps() .AND. ;
               !( Right( cDir, 2 ) == hb_osDriveSeparator() + hb_ps() )
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ENDIF

   RETURN cDir

STATIC FUNCTION PathSepToSelf( cFileName )
#if defined( __PLATFORM__WINDOWS ) .OR. ;
    defined( __PLATFORM__DOS ) .OR. ;
    defined( __PLATFORM__OS2 )
   RETURN StrTran( cFileName, "/", "\" )
#else
   RETURN StrTran( cFileName, "\", "/" )
#endif
