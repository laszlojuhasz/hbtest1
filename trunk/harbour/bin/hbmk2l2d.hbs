/*
 * $Id$
 */

/*
 * hbmk2 plugin script, static lib to dynamic lib conversion for
 * environments supporting 'ar' tool.
 * Usage:
 *    'hbmk2 -hbdyn -pi=<libsrc.a> -plugin=hbmk2l2d.hbs -o<dynlibdst> -nohblib-'
  *
 * Copyright 2010 Viktor Szakats (harbour.01 syenar.hu)
 * www - http://harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

#pragma warninglevel=3
#pragma -km+
#pragma -ko+

#define I_( x )                 hb_i18n_gettext( x )

#if defined( __HBSCRIPT__HBMK )

FUNCTION hbmk2_plugin_lib2dyn( hbmk2 )
   LOCAL cRetVal := ""

   LOCAL cSrc

   LOCAL cCommand
   LOCAL nError

   LOCAL cStdOut
   LOCAL cLine

   LOCAL cOldDir

   SWITCH hbmk2[ "cSTATE" ]
   CASE "init"

      hbmk2[ "vars" ][ "aOBJ_Src" ] := {}
      EXIT

   CASE "pre_all"

      /* Gather input parameters */

      hbmk2[ "vars" ][ "aLIB_Src" ] := {}

      FOR EACH cSrc IN hbmk2[ "params" ]
         SWITCH Lower( hbmk2_FNameExtGet( cSrc ) )
         CASE ".a"
            AAdd( hbmk2[ "vars" ][ "aLIB_Src" ], cSrc )
            EXIT
         ENDSWITCH
      NEXT

      FOR EACH cSrc IN hbmk2[ "vars" ][ "aLIB_Src" ]

         cCommand := "ar" +;
                     " -t" +;
                     " " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cSrc ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] )

         IF hbmk2[ "lTRACE" ]
            IF ! hbmk2[ "lQUIET" ]
               hbmk2_OutStd( hbmk2, I_( "'ar' command:" ) )
            ENDIF
            hbmk2_OutStdRaw( cCommand )
         ENDIF

         IF ! hbmk2[ "lDONTEXEC" ]
            IF ( nError := hb_processRun( cCommand,, @cStdOut ) ) != 0
               hbmk2_OutErr( hbmk2, hb_StrFormat( I_( "Error: Running 'ar' executable. %1$s" ), hb_ntos( nError ) ) )
               IF ! hbmk2[ "lQUIET" ]
                  hbmk2_OutErrRaw( cCommand )
               ENDIF
               IF ! hbmk2[ "lIGNOREERROR" ]
                  cRetVal := "error"
                  EXIT
               ENDIF
            ELSE
               FOR EACH cLine IN hb_ATokens( StrTran( cStdOut, Chr( 13 ) ), Chr( 10 ) )
                  IF ! Empty( cLine )
                     cLine := hbmk2_FNameDirExtSet( hbmk2_FNameNameGet( cLine ), hbmk2[ "cWorkDir" ] )
                     AAdd( hbmk2[ "vars" ][ "aOBJ_Src" ], cLine )
                     hbmk2_AddInput_OBJ( hbmk2, cLine )
                  ENDIF
               NEXT
            ENDIF
         ENDIF
      NEXT

      EXIT

   CASE "pre_all"

      EXIT

   CASE "pre_link"

      IF ! hbmk2[ "lCLEAN" ] .AND. ;
         ! Empty( hbmk2[ "vars" ][ "aLIB_Src" ] )

         FOR EACH cSrc IN hbmk2[ "vars" ][ "aLIB_Src" ]

            cCommand := "ar" +;
                        " -x" +;
                        " " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, hbmk2_PathNormalize( hbmk2_PathMakeAbsolute( cSrc, hbmk2_PathFromWorkdirToCWD( hbmk2 ) ) ) ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] )

            IF hbmk2[ "lTRACE" ]
               IF ! hbmk2[ "lQUIET" ]
                  hbmk2_OutStd( hbmk2, I_( "'ar' command:" ) )
               ENDIF
               hbmk2_OutStdRaw( cCommand )
            ENDIF

            IF ! hbmk2[ "lDONTEXEC" ]
               cOldDir := hbmk2_CWD()
               DirChange( hbmk2[ "cWorkDir" ] )
               IF ( nError := hb_processRun( cCommand ) ) != 0
                  DirChange( cOldDir )
                  hbmk2_OutErr( hbmk2, hb_StrFormat( I_( "Error: Running 'ar' executable. %1$s" ), hb_ntos( nError ) ) )
                  IF ! hbmk2[ "lQUIET" ]
                     hbmk2_OutErrRaw( cCommand )
                  ENDIF
                  IF ! hbmk2[ "lIGNOREERROR" ]
                     cRetVal := "error"
                     EXIT
                  ENDIF
               ELSE
                  DirChange( cOldDir )
               ENDIF
            ENDIF
         NEXT
      ENDIF

      EXIT

   CASE "pre_c"

      EXIT

   CASE "post_all"

      IF ! hbmk2[ "lINC" ] .OR. hbmk2[ "lCLEAN" ]
         AEval( hbmk2[ "vars" ][ "aOBJ_Src" ], {| tmp | FErase( tmp ) } )
      ENDIF

      EXIT

   ENDSWITCH

   RETURN cRetVal

#endif
