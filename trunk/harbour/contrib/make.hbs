#!/usr/bin/hbrun --hb:gtcgi
/*
 * $Id$
 */

/*
 * Contrib build starter script.
 *
 * Copyright 2010 Viktor Szakats (harbour.01 syenar.hu)
 * See COPYING for licensing terms.
 */

/* TODO:
     0. normalize path to hbpre/hbpost to save on cmdline
     1. error handling / reporting / feedback
     2. clean this source to avoid redundancy
     3. solve HB_BUILD_CONTRIB_DLL support the .dlls are either
        huge, or they don't link.
     4. hbmk2 location detection in standalone mode
        (move hbmk2 to core lib?)
     5. gnumake mode: automatically decide about build order,
        based on dependencies (implibs -> libs[TODO!] -> exes)
     7. Move in external libs to contrib area? (bz2, minizip, sqlite3)
     8. Pull the list of .hbp files from an external file
        (so it can be used in stdalone mode, and the script can be
        moved to bin and used in more generic way f.e. for examples
        and local projects)
     9. 'install' is ignored in stdalone mode. It would be needed to
        replicate the install dir defaulting logic found in global.mk
 */

#pragma warninglevel=3

/* ----------------------------------------------------------------------- */

STATIC s_aList := {;
   { 1, "hbblink/hbblink.hbp"        },;
   { 1, "hbbz2/hbbz2.hbp"            },; /* uses: bz2 (external) */
   { 1, "hbclipsm/hbclipsm.hbp"      },;
   { 1, "hbcomm/hbcomm.hbp"          },;
   { 1, "hbct/hbct.hbp"              },;
   { 1, "hbfoxpro/hbfoxpro.hbp"      },;
   { 1, "hbfship/hbfship.hbp"        },;
   { 1, "hbgt/hbgt.hbp"              },;
   { 1, "hbmemio/hbmemio.hbp"        },;
   { 1, "hbmisc/hbmisc.hbp"          },;
   { 1, "hbmzip/hbmzip.hbp"          },; /* uses: minizip (external) */
   { 1, "hbnetio/hbnetio.hbp"        },;
   { 1, "hbnf/hbnf.hbp"              },;
   { 1, "hbodbc/hbodbc.hbp"          },;
   { 1, "hbsms/hbsms.hbp"            },;
   { 1, "hbsqlit3/hbsqlit3.hbp"      },; /* uses: sqlite3 (external) */
   { 1, "hbtpathy/hbtpathy.hbp"      },;
   { 1, "hbwin/hbwin.hbp"            },;
   { 1, "hbxpp/hbxpp.hbp"            },;
   { 1, "rddbmcdx/hbbmcdx.hbp"       },;
   { 2, "gtalleg/gtalleg.hbp"        },;
   { 2, "gtalleg/gtallegs.hbp"       },;
   { 2, "hbblat/hbblat.hbp"          },;
   { 2, "hbcairo/hbcairo.hbp"        },;
   { 2, "hbcups/hbcups.hbp"          },;
   { 2, "hbcurl/hbcurl.hbp"          },;
   { 2, "hbcurl/hbcurls.hbp"         },;
   { 2, "hbfbird/hbfbird.hbp"        },;
   { 2, "hbfimage/hbfimage.hbp"      },;
   { 2, "hbgd/hbgd.hbp"              },; /* uses: hbct */
   { 2, "hbhpdf/hbhpdf.hbp"          },;
   { 2, "hbmysql/hbmysql.hbp"        },;
   { 2, "hbpgsql/hbpgsql.hbp"        },;
   { 2, "hbqt/hbqt.hbp"              },;
   { 2, "hbqt/hbqtcore.hbp"          },;
   { 2, "hbqt/hbqtcores.hbp"         },;
   { 2, "hbqt/hbqtgui.hbp"           },;
   { 2, "hbqt/hbqtguis.hbp"          },;
   { 2, "hbqt/hbqtnetwork.hbp"       },;
   { 2, "hbqt/hbqtnetworks.hbp"      },;
   { 2, "hbqt/hbqts.hbp"             },;
   { 2, "hbssl/hbssl.hbp"            },;
   { 2, "hbssl/hbssls.hbp"           },;
   { 2, "hbxbp/hbxbp.hbp"            },; /* uses: hbqt */
   { 2, "rddads/rddads.hbp"          },;
   { 2, "rddsql/rddsql.hbp"          },;
   { 2, "sddfb/sddfb.hbp"            },; /* uses: rddsql */
   { 2, "sddmy/sddmy.hbp"            },; /* uses: rddsql */
   { 2, "sddoci/sddoci.hbp"          },; /* uses: rddsql */
   { 2, "sddodbc/sddodbc.hbp"        },; /* uses: rddsql */
   { 2, "sddpg/sddpg.hbp"            },; /* uses: rddsql */
   { 2, "sddsqlt3/sddsqlt3.hbp"      },; /* uses: rddsql, sqlite3 (external) */
   { 3, "gtwvg/gtwvg.hbp"            },; /* uses: hbwin */
   { 3, "hbtip/hbtip.hbp"            },;
   { 3, "hbtip/hbtipssl.hbp"         },; /* uses: hbssl */
   { 3, "hbziparc/hbziparc.hbp"      },; /* uses: hbmzip */
   { 3, "xhb/xhb.hbp"                },; /* uses: hbct, hbtip, hbwin */
   { 4, "hbdoc2/hbdoc2.hbp"          },;
   { 4, "hbnetio/utils/hbnetio.hbp"  },; /* uses: hbnetio */
   { 4, "hbide/hbide.hbp"            }}  /* uses: hbxbp, hbqt */

STATIC s_aAddons := {}

/* ----------------------------------------------------------------------- */

/* TOFIX: Ugly hack to avoid #include "directry.ch" */
#define F_NAME                  1       /* File name */
#define F_ATTR                  5       /* File attribute */

#define _ACT_EXIT               0
#define _ACT_CLEAN              1
#define _ACT_INC                2
#define _ACT_INC_INST           3
#define _ACT_INC_REBUILD_INST   4

STATIC hActions := {;
   _ACT_CLEAN            => "clean" ,;
   _ACT_INC              => "build" ,;
   _ACT_INC_INST         => "build and install" ,;
   _ACT_INC_REBUILD_INST => "rebuild and install" }

STATIC s_cBase
STATIC s_cHome
STATIC s_cRoot
STATIC s_lTest

PROCEDURE Main( ... )
   LOCAL tmp

   s_cBase := ""
   s_cHome := StrTran( hb_DirBase(), hb_ps(), "/" )
   s_cRoot := s_cHome + "../"

   s_lTest := "test" $ hb_cmdLine()

   IF "migr" $ hb_cmdLine() // .OR. .T.
      hb_setenv( "_HB_BUILD_MIGR", "yes" )
   ENDIF

   /* Making sure that user settings do not interfere with the std build process. */
   hb_setenv( "HBMK_OPTIONS" )

   FOR EACH tmp IN hb_ATokens( GetEnv( "HB_BUILD_ADDONS" ),, .T. )
      IF ! Empty( tmp )
         AAdd( s_aAddons, { 9, StrTran( tmp, "\", "/" ) } )
      ENDIF
   NEXT

   IF Empty( GetEnv( "HB_HOST_BIN_DIR" ) )
      StandAlone( ... )
   ELSE
      GNUMake( ... )
   ENDIF

   RETURN

/*
  Workflow translation for standalone operation:

     GNU Make       parameter      nAction                hbmk2 options
  -- -------------- -------------- ---------------------- -------------------------
  #1 clean          clean          _ACT_CLEAN             -clean
  #2 install        install        _ACT_INC_INST          -inc -instpath=
  #3 clean install  clean install  _ACT_INC_REBUILD_INST  -inc -instpath= -rebuild
  #4                               _ACT_INC               -inc

 */
PROCEDURE StandAlone( ... )
   LOCAL aParams

   LOCAL aFile
   LOCAL cType
   LOCAL aDept

   LOCAL cBinDir
   LOCAL cProject

   LOCAL cBaseOptions

   LOCAL nAction
   LOCAL tmp

   aParams := hb_AParams()

   DO CASE
   CASE AScanL( aParams, "clean" ) > 0 .AND. ;
        AScanL( aParams, "install" ) > 0 .AND. ;
        AScanL( aParams, "install" ) > AScanL( aParams, "clean" )
      nAction := _ACT_INC_REBUILD_INST
   CASE AScanL( aParams, "clean" ) > 0
      nAction := _ACT_CLEAN
   CASE AScanL( aParams, "install" ) > 0
      nAction := _ACT_INC_INST
   OTHERWISE
      nAction := _ACT_INC
   ENDCASE

   IF nAction == _ACT_EXIT
      ErrorLevel( 0 )
      RETURN
   ENDIF

   SetCancel( .F. )

   /* Converting build options to hbmk2 options */

   cBaseOptions := ""

   IF nAction == _ACT_CLEAN
      cBaseOptions += " -clean"
   ELSE
      cBaseOptions += " -inc"
      IF nAction == _ACT_INC_REBUILD_INST
         cBaseOptions += " -rebuild"
      ENDIF
   ENDIF

   FOR EACH tmp IN aParams
      IF !( Lower( tmp ) == "install" ) .AND. ;
         !( Lower( tmp ) == "clean" ) .AND. ;
         !( Lower( tmp ) == "all" )
         cBaseOptions += " " + tmp
      ENDIF
   NEXT

   cBinDir := s_cRoot + "bin" + hb_ps()

   FOR EACH aFile IN Directory( "*.hbp" )

      /* TODO: If project not on official project list, pass the raw call to hbmk2 */
      /* TODO: Also rebuild the dependencies (in proper order) */

      cProject := s_cBase + StrTran( aFile[ F_NAME ], "\", "/" )

      call_hbmk2_dept( s_cRoot + "bin" + hb_ps(), cProject, @cType, @aDept )

      OutStd( cProject + " type: " + cType )
      IF ! Empty( aDept )
         OutStd( " depends on: " )
         AEval( aDept, {| tmp | OutStd( tmp ) } )
      ENDIF
      OutStd( hb_eol() )

      IF cType $ "hbhrb|hbppo"
         LOOP
      ENDIF

      call_hbmk2( cBinDir, cProject, cBaseOptions, "" )

      IF hb_FileExists( PathSepToSelf( FNameExtSet( cProject, ".hbi" ) ) )
         call_hbmk2( cBinDir, FNameExtSet( cProject, ".hbi" ), cBaseOptions, "" )
      ENDIF
   NEXT

   ErrorLevel( 0 )

   RETURN

/*
  Workflow translation from GNU Make to hbmk2:

     GNU Make       parameter  HB_MAKECMDGOALS  nAction                hbmk2 options
  -- -------------- ---------- ---------------- ---------------------- -------------------------
  #1 clean          clean      clean            _ACT_CLEAN             -clean
  #2 install        install    install          _ACT_INC_INST          -inc -instpath=
  #3 clean install  clean      clean install    _ACT_CLEAN             -clean
                    install    clean install    _ACT_INC_REBUILD_INST  -inc -instpath= -rebuild
  #4 install clean  install    install clean    _ACT_INC_INST          -inc -instpath=
                    clean      install clean    _ACT_CLEAN             -clean
  #5                all                         _ACT_INC               -inc

 */

PROCEDURE GNUMake( ... )
   LOCAL cType

   LOCAL cBinDir
   LOCAL aProject
   LOCAL cProject
   LOCAL cProjectDir

   LOCAL cBaseOptions

   LOCAL cFilter
   LOCAL aFilter
   LOCAL lFilterNegative

   LOCAL aParams
   LOCAL aGNUMakeParams
   LOCAL nAction

   /* Check if the requirements are met and if we have anything to do */

   IF Empty( GetEnv( "HB_PLATFORM" ) ) .OR. ;
      Empty( GetEnv( "HB_COMPILER" ) ) .OR. ;
      Empty( GetEnv( "HB_HOST_BIN_DIR" ) )
      ErrorLevel( 9 )
      RETURN
   ENDIF

   cFilter := GetEnv( "HB_BUILD_CONTRIBS" )
   /* Compatibility */
   IF Empty( cFilter )
      cFilter := GetEnv( "HB_CONTRIBLIBS" )
   ENDIF

   IF cFilter == "no"
      ErrorLevel( 0 )
      RETURN
   ENDIF

   /* Determine the mode of operation */

   aParams := hb_AParams()
   aGNUMakeParams := hb_ATokens( Lower( GetEnv( "HB_MAKECMDGOALS" ) ) )

   DO CASE
   CASE AScanL( aParams, "clean" ) > 0
      IF AScanL( aGNUMakeParams, "clean" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > AScanL( aGNUMakeParams, "clean" )
         nAction := _ACT_CLEAN
      ELSE
         nAction := _ACT_CLEAN
      ENDIF
   CASE AScanL( aParams, "install" ) > 0
      IF AScanL( aGNUMakeParams, "clean" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > AScanL( aGNUMakeParams, "clean" )
         /* Use rebuild mode. This is needed because the clean phase
            might not have been called previously by GNU Make, f.e.
            because hbrun or hbmk2 wasn't available. -rebuild is
            costless, so we do it to make sure to build cleanly.
            [vszakats] */
         nAction := _ACT_INC_REBUILD_INST
      ELSE
         nAction := _ACT_INC_INST
      ENDIF
   OTHERWISE
      nAction := _ACT_INC
   ENDCASE

   IF nAction == _ACT_EXIT
      ErrorLevel( 0 )
      RETURN
   ENDIF

   SetCancel( .F. )

   /* Parse filter */

   aFilter := iif( Empty( cFilter ), {}, hb_ATokens( cFilter,, .T. ) )
   IF Len( aFilter ) >= 1 .AND. aFilter[ 1 ] == "no"
      hb_ADel( aFilter, 1, .T. )
      lFilterNegative := .T.
   ELSE
      lFilterNegative := .F.
   ENDIF

   /* Clearing envvars that may interact with hbmk2 */

   /* Saving original install dirs to our own variables */
   hb_setenv( "_HB_BIN_INSTALL", GetEnv( "HB_BIN_INSTALL" ) )
   hb_setenv( "_HB_LIB_INSTALL", GetEnv( "HB_LIB_INSTALL" ) )
   hb_setenv( "_HB_DYN_INSTALL", GetEnv( "HB_DYN_INSTALL" ) )
   hb_setenv( "_HB_INC_INSTALL", GetEnv( "HB_INC_INSTALL" ) )

   /* Override hbmk2 autodetection */
   hb_setenv( "HB_INSTALL_PREFIX", s_cRoot )
   hb_setenv( "HB_BIN_INSTALL", s_cRoot + "bin/" + GetEnv( "HB_PLATFORM" ) + "/" + GetEnv( "HB_COMPILER" ) + GetEnv( "HB_BUILD_NAME" ) )
   hb_setenv( "HB_LIB_INSTALL", s_cRoot + "lib/" + GetEnv( "HB_PLATFORM" ) + "/" + GetEnv( "HB_COMPILER" ) + GetEnv( "HB_BUILD_NAME" ) )
   hb_setenv( "HB_DYN_INSTALL" )
   hb_setenv( "HB_INC_INSTALL", s_cRoot + "include" )

   /* Preprocessing */

   cBinDir := GetEnv( "HB_HOST_BIN_DIR" ) + hb_ps()

// OutStd( Len( s_aList ) ) ; s_aList := { { 1, "rddads/rddads.hbp" } }

   OutStd( "! Calculating sorting order for contribs..." + hb_eol() )

   FOR EACH aProject IN s_aList
      cProject := aProject[ 2 ]
      ASize( aProject, 4 )
      call_hbmk2_dept( cBinDir, s_cBase + cProject, @aProject[ 3 ], @aProject[ 4 ] )

//      OutStd( cProject + " type: " + aProject[ 3 ] )
//      IF ! Empty( aProject[ 4 ] )
//         OutStd( " depends on: " )
//         AEval( aProject[ 4 ], {| tmp | OutStd( tmp ) } )
//      ENDIF
//      OutStd( hb_eol() )
   NEXT

   ASort( s_aList, {| tmp, tmp1 | tmp[ 1 ] > tmp1[ 1 ] } )

   /* Converting build options to hbmk2 options */

   hb_setenv( "_HB_BUILD_INSTALL" )

   cBaseOptions := ""

   IF nAction == _ACT_CLEAN
      cBaseOptions += " -clean"
   ELSE
      cBaseOptions += " -inc"
      IF nAction == _ACT_INC_REBUILD_INST
         cBaseOptions += " -rebuild"
      ENDIF
      IF nAction == _ACT_INC_INST .OR. ;
         nAction == _ACT_INC_REBUILD_INST
         hb_setenv( "_HB_BUILD_INSTALL", "yes" )
      ENDIF
   ENDIF

   /* Start building */

   OutStd( hb_StrFormat( "! Contribs %1$s...", hActions[ nAction ] ) + hb_eol() )

   FOR EACH aProject IN s_aList

      cProject := aProject[ 2 ]

      cProjectDir := StrTran( FNameDirGet( PathSepToSelf( cProject ) ), "\", "/" )
      cProject := s_cBase + cProject

      IF Empty( aFilter ) .OR. ;
         iif( lFilterNegative,;
            AScan( aFilter, {| tmp | tmp == cProjectDir } ) == 0,;
            AScan( aFilter, {| tmp | tmp == cProjectDir } ) > 0 )

         cType := get_hbmk2_project_type( cProject )

         IF cType $ "hbhrb|hbppo"
            LOOP
         ENDIF

         call_hbmk2( cBinDir, cProject, cBaseOptions, "" )

         IF hb_FileExists( PathSepToSelf( FNameExtSet( cProject, ".hbi" ) ) )
            call_hbmk2( cBinDir, FNameExtSet( cProject, ".hbi" ), cBaseOptions, "" )
         ENDIF

         /* Highly experimental */
         IF cType == "hblib" .AND. ;
            GetEnv( "HB_BUILD_CONTRIB_DLL" ) == "yes" .AND. ;
            hb_FileExists( PathSepToSelf( FNameExtSet( cProject, ".hbc" ) ) )

            call_hbmk2( cBinDir, cProject, cBaseOptions, " -hbdyn -nohblib- -implib " + FNameExtSet( cProject, ".hbc" ) )
         ENDIF

         IF nAction == _ACT_INC_INST .OR. ;
            nAction == _ACT_INC_REBUILD_INST
            mk_hbd( PathSepToSelf( cProjectDir ) )
         ENDIF
      ELSE
         /* OutStd( hb_StrFormat( "! project '%1$s' skipped", cProject ) + hb_eol() ) */
      ENDIF
   NEXT

   ErrorLevel( 0 )

   RETURN

STATIC FUNCTION call_hbmk2_dept( cBinDir, cProject, /* @ */ cType, /* @ */ aDept )
   LOCAL tmp, tmp1

   cType := ""
   aDept := {}

   IF hb_processRun( PathSepToSelf( cBinDir ) + "hbmk2 --hbinfo " + StrTran( cProject, "\", "/" ),, @tmp  ) == 0

      IF ( tmp1 := At( "targettype{{", tmp ) ) > 0
         tmp := SubStr( tmp, tmp1 + Len( "targettype{{" ) )
         IF ( tmp1 := At( "}}", tmp ) ) > 0
            cType := Left( tmp, tmp1 - 1 )
         ENDIF
      ENDIF

      IF ( tmp1 := At( "hbctree{{", tmp ) ) > 0
         tmp := SubStr( tmp, tmp1 + Len( "hbctree{{" ) )
         IF ( tmp1 := At( "}}", tmp ) ) > 0
            tmp := StrTran( Left( tmp, tmp1 - 1 ), Chr( 13 ) )
            FOR EACH tmp IN hb_ATokens( tmp, Chr( 10 ) )
               IF ! Empty( tmp )
                  hb_FNameSplit( tmp,, @tmp1 )
                  AAdd( aDept, tmp1 )
               ENDIF
            NEXT
         ENDIF
      ENDIF

      RETURN .T.
   ENDIF

   RETURN .F.

STATIC FUNCTION call_hbmk2( cBinDir, cProject, cOptionsPre, cOptionsPost )
   LOCAL nErrorLevel

   nErrorLevel := mk_hb_processRun( PathSepToSelf( cBinDir ) + "hbmk2" +;
                                    " -lang=en -width=0" +;
                                    " @" + StrTran( s_cHome + "hbpre", "\", "/" ) +;
                                    cOptionsPre +;
                                    " " + StrTran( cProject, "\", "/" ) +;
                                    " @" + StrTran( s_cHome, "\", "/" ) + "hbpost" +;
                                    cOptionsPost )

   IF nErrorLevel != 0
      OutStd( hb_StrFormat( "! '%s' returned status: %s", cProject, hb_ntos( nErrorLevel ) ) + hb_eol() )
      RETURN .F.
   ENDIF

   RETURN .T.

STATIC FUNCTION mk_hb_processRun( cCommand )

   OutStd( cCommand + hb_eol() )

   RETURN iif( s_lTest, 0, hb_processRun( cCommand ) )

STATIC FUNCTION mk_hbd( cDir )
   LOCAL cName
   LOCAL tmp

   LOCAL aErrMsg
   LOCAL aEntry

   IF ! Empty( GetEnv( "HB_DOC_INSTALL" ) )

      cName := DirGetName( cDir )
      IF Empty( cName )
         cName := "harbour"
      ENDIF

      aErrMsg := {}
      aEntry := __hbdoc_LoadDir( cDir, cName, aErrMsg )

      FOR EACH tmp IN aErrMsg
         OutErr( hb_StrFormat( "! %1$s", tmp ) + hb_eol() )
      NEXT

      IF ! Empty( aEntry )
         cName := PathSepToSelf( GetEnv( "HB_DOC_INSTALL" ) ) + hb_ps() + cName + ".hbd"
         IF __hbdoc_SaveHBD( cName, aEntry )
            OutStd( "! Compiled documentation: " + cName + " <= " + cDir + hb_eol() )
            RETURN .T.
         ELSE
            OutErr( hb_StrFormat( "! Error: Saving '%1$s'", cName ) + hb_eol() )
         ENDIF
      ENDIF
   ENDIF

   RETURN .F.

STATIC FUNCTION get_hbmk2_project_type( cFileName )
   LOCAL cFile := MemoRead( PathSepToSelf( cFileName ) )

   IF     "-hblib"    $ cFile ; RETURN "hblib"
   ELSEIF "-hbimplib" $ cFile ; RETURN "hbimplib"
   ELSEIF "-hbdyn"    $ cFile ; RETURN "hbdyn"
   ELSEIF "-gh"       $ cFile ; RETURN "hbhrb"
   ENDIF

   RETURN "hbexe"

STATIC FUNCTION AScanL( aArray, cString )
   RETURN AScan( aArray, {| tmp | Lower( tmp ) == cString } )

STATIC FUNCTION FNameDirGet( cFileName )
   LOCAL cDir

   hb_FNameSplit( cFileName, @cDir )

   RETURN cDir

STATIC FUNCTION FNameExtSet( cFileName, cExt )
   LOCAL cDir, cName

   hb_FNameSplit( cFileName, @cDir, @cName )

   RETURN hb_FNameMerge( cDir, cName, cExt )

STATIC FUNCTION DirGetName( cDir )
   LOCAL cName

   cDir := DirDelPathSep( cDir )

   hb_FNameSplit( cDir,, @cName )

   IF Empty( cName ) .OR. cName == "." .OR. cName == ".."
      RETURN ""
   ENDIF

   RETURN cName

STATIC FUNCTION DirDelPathSep( cDir )

   IF Empty( hb_osDriveSeparator() )
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps()
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ELSE
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps() .AND. ;
               !( Right( cDir, 2 ) == hb_osDriveSeparator() + hb_ps() )
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ENDIF

   RETURN cDir

STATIC FUNCTION PathSepToSelf( cFileName )
#if defined( __PLATFORM__WINDOWS ) .OR. ;
    defined( __PLATFORM__DOS ) .OR. ;
    defined( __PLATFORM__OS2 )
   RETURN StrTran( cFileName, "/", "\" )
#else
   RETURN StrTran( cFileName, "\", "/" )
#endif
