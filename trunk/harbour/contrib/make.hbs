#!/usr/bin/hbrun --hb:gtcgi
/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * Contrib build orchestrator script
 *
 * Copyright 2010 Viktor Szakats (harbour.01 syenar.hu)
 * www - http://harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

/* TODO:
     1. normalize path to hbpre/hbpost to save on cmdline
     2. clean this source to avoid redundancy
     3. solve HB_BUILD_CONTRIB_DLL support the .dlls are either
        huge, or they don't link.
     4. hbmk2 location detection in standalone mode
        (or move hbmk2 to core lib?)
     5. Move in external libs to contrib area? (bz2, minizip, sqlite3)
     6. Pull the list of .hbp files from an external file
        (so it can be used in stdalone mode, and the script can be
        moved to bin and used in more generic way f.e. for examples
        and local projects)
     7. 'install' is ignored in stdalone mode. It would be needed to
        replicate the install dir defaulting logic found in global.mk
        to implement it.
     8. Delete header install related logic from GNU Make system,
        also delete doc/*.txt install related logic (easily replacable
        with postinst.hbs logic)
     9. Move some logic to hbmk2.
    10. Honor paths found in --hbinfo hbctree{{}} section.
 */

#pragma warninglevel=3

/* ----------------------------------------------------------------------- */

STATIC s_hPackageList := {;
   "gtalleg"       => { "gtalleg.hbp", "gtallegs.hbp" },;
   "gtwvg"         => { "gtwvg.hbp"                   },;
   "hbblat"        => { "hbblat.hbp"                  },;
   "hbblink"       => { "hbblink.hbp"                 },;
   "hbbz2"         => { "hbbz2.hbp"                   },; /* uses: bz2 (external) */
   "hbcairo"       => { "hbcairo.hbp"                 },;
   "hbclipsm"      => { "hbclipsm.hbp"                },;
   "hbcomm"        => { "hbcomm.hbp"                  },;
   "hbct"          => { "hbct.hbp"                    },;
   "hbcups"        => { "hbcups.hbp"                  },;
   "hbcurl"        => { "hbcurl.hbp", "hbcurls.hbp"   },;
   "hbdoc2"        => { "hbdoc2.hbp"                  },;
   "hbfbird"       => { "hbfbird.hbp"                 },;
   "hbfimage"      => { "hbfimage.hbp"                },;
   "hbfoxpro"      => { "hbfoxpro.hbp"                },;
   "hbfship"       => { "hbfship.hbp"                 },;
   "hbgd"          => { "hbgd.hbp"                    },;
   "hbgt"          => { "hbgt.hbp"                    },;
   "hbhpdf"        => { "hbhpdf.hbp"                  },;
   "hbide"         => { "hbide.hbp"                   },;
   "hbmemio"       => { "hbmemio.hbp"                 },;
   "hbmisc"        => { "hbmisc.hbp"                  },;
   "hbmysql"       => { "hbmysql.hbp"                 },;
   "hbmzip"        => { "hbmzip.hbp"                  },; /* uses: minizip (external) */
   "hbnetio"       => { "hbnetio.hbp"                 },;
   "hbnetio/utils" => { "hbnetio.hbp"                 },;
   "hbnf"          => { "hbnf.hbp"                    },;
   "hbodbc"        => { "hbodbc.hbp"                  },;
   "hbpgsql"       => { "hbpgsql.hbp"                 },;
   "hbqt"          => { "hbqt.hbp", "hbqts.hbp", "hbqtcore.hbp", "hbqtcores.hbp", "hbqtgui.hbp", "hbqtguis.hbp", "hbqtnetwork.hbp", "hbqtnetworks.hbp" },;
   "hbsms"         => { "hbsms.hbp"                   },;
   "hbsqlit3"      => { "hbsqlit3.hbp"                },; /* uses: sqlite3 (external) */
   "hbssl"         => { "hbssl.hbp", "hbssls.hbp"     },;
   "hbtip"         => { "hbtip.hbp", "hbtipssl.hbp"   },;
   "hbtpathy"      => { "hbtpathy.hbp"                },;
   "hbwin"         => { "hbwin.hbp"                   },;
   "hbxbp"         => { "hbxbp.hbp"                   },;
   "hbxpp"         => { "hbxpp.hbp"                   },;
   "hbziparc"      => { "hbziparc.hbp"                },;
   "rddads"        => { "rddads.hbp"                  },;
   "rddbmcdx"      => { "rddbmcdx.hbp"                },;
   "rddsql"        => { "rddsql.hbp"                  },;
   "sddfb"         => { "sddfb.hbp"                   },;
   "sddmy"         => { "sddmy.hbp"                   },;
   "sddoci"        => { "sddoci.hbp"                  },;
   "sddodbc"       => { "sddodbc.hbp"                 },;
   "sddpg"         => { "sddpg.hbp"                   },;
   "sddsqlt3"      => { "sddsqlt3.hbp"                },; /* uses: sqlite3 (external) */
   "xhb"           => { "xhb.hbp"                     }}

/* ----------------------------------------------------------------------- */

/* TOFIX: Ugly hack to avoid #include "directry.ch" */
#define F_NAME                  1       /* File name */
#define F_ATTR                  5       /* File attribute */

#define _ACT_CLEAN              1
#define _ACT_INC                2
#define _ACT_INC_INST           3
#define _ACT_INC_REBUILD_INST   4

STATIC hActions := {;
   _ACT_CLEAN            => "clean" ,;
   _ACT_INC              => "build" ,;
   _ACT_INC_INST         => "build and install" ,;
   _ACT_INC_REBUILD_INST => "rebuild and install" }

STATIC s_cBase
STATIC s_cHome
STATIC s_cRoot
STATIC s_lTest

PROCEDURE Main( ... )
   LOCAL aProject
   LOCAL tmp

   SetCancel( .F. )

   s_cBase := ""
   s_cHome := StrTran( hb_DirBase(), hb_ps(), "/" )
   s_cRoot := s_cHome + "../"

   s_lTest := "test" $ hb_cmdLine()

   IF "migr" $ hb_cmdLine()
      hb_setenv( "_HB_BUILD_MIGR", "yes" )
   ENDIF

   /* Convert list of contribs */

   FOR EACH aProject IN s_hPackageList
      FOR EACH tmp IN aProject
         tmp := { "cFileName" => tmp }
      NEXT
   NEXT

   /* Build */

   IF Empty( GetEnv( "HB_HOST_BIN_DIR" ) )
      Standalone( ... )
   ELSE
      GNUMake( ... )
   ENDIF

   RETURN

/* Workflow translation for standalone operation:

      GNU Make       parameter      nAction                hbmk2 options
   -- -------------- -------------- ---------------------- -------------------------
   #1 clean          clean          _ACT_CLEAN             -clean
   #2 install        install        _ACT_INC_INST          -inc -instpath=
   #3 clean install  clean install  _ACT_INC_REBUILD_INST  -inc -instpath= -rebuild
   #4                               _ACT_INC               -inc
 */
PROCEDURE Standalone( ... )
   LOCAL aParams

   LOCAL aFileList
   LOCAL aFile

   LOCAL aSortedList

   LOCAL cBinDir
   LOCAL hProject
   LOCAL cDir

   LOCAL cOptions
   LOCAL cOptionsUser

   LOCAL nAction
   LOCAL tmp

   LOCAL lCustom

   LOCAL aPairList

   /* Processing cmdline options */

   aParams := hb_AParams()

   DO CASE
   CASE AScanL( aParams, "clean" ) > 0 .AND. ;
        AScanL( aParams, "install" ) > 0 .AND. ;
        AScanL( aParams, "install" ) > AScanL( aParams, "clean" )
      nAction := _ACT_INC_REBUILD_INST
   CASE AScanL( aParams, "clean" ) > 0
      nAction := _ACT_CLEAN
   CASE AScanL( aParams, "install" ) > 0
      nAction := _ACT_INC_INST
   OTHERWISE
      nAction := _ACT_INC
   ENDCASE

   cOptionsUser := ""
   lCustom := .F.
   FOR EACH tmp IN aParams
      IF !( Lower( tmp ) == "install" ) .AND. ;
         !( Lower( tmp ) == "clean" ) .AND. ;
         !( Lower( tmp ) == "all" ) .AND. ;
         !( Lower( tmp ) == "first" )

         cOptionsUser += " " + tmp

         /* If anything else is passed the options or GNU Make keywords,
            consider it a custom project build, f.e. in tests */
         IF !( Left( tmp, 1 ) == "-" )
            lCustom := .T.
         ENDIF
      ENDIF
   NEXT

   cBinDir := s_cRoot + "bin" + hb_ps()

   IF lCustom
      mk_hb_processRun( PathSepToSelf( cBinDir ) + "hbmk2" + cOptionsUser )
   ELSE
      /* Converting build options to hbmk2 options */

      cOptions := ""

      IF nAction == _ACT_CLEAN
         cOptions += " -clean"
      ELSE
         cOptions += " -inc"
         IF nAction == _ACT_INC_REBUILD_INST
            cOptions += " -rebuild"
         ENDIF
      ENDIF

      aFileList := Directory( "*.hbp" )
      IF ! Empty( aFileList )

         /* Add the project in current dir */
         s_hPackageList[ "." ] := {}
         FOR EACH aFile IN aFileList
            AAdd( s_hPackageList[ "." ], { "cFileName" => aFile[ F_NAME ] } )
         NEXT

         /* Query project information and dependencies and calculate build order */
         aPairList := {}

         FOR EACH hProject IN s_hPackageList[ "." ]
            call_hbmk2_hbinfo( cBinDir, s_cBase + hProject[ "cFileName" ], hProject )
            DeptLinesToDeptPairList( aPairList, ".", hProject[ "aDept" ] )
         NEXT

         aSortedList := TopoSort( aPairList )

         /* Build the dependencies and ourselves in in sorted order */
         FOR EACH cDir IN aSortedList DESCEND
            FOR EACH hProject IN s_hPackageList[ cDir ]
               IF cDir == "." .AND. hProject[ "cType" ] $ "hbhrb|hbppo"
                  LOOP
               ENDIF
               call_hbmk2( cBinDir,;
                  s_cBase + iif( cDir == ".", "", s_cHome + cDir + "/" ) + hProject[ "cFileName" ],;
                  iif( cDir == ".", cOptions + cOptionsUser, "" ), "" )
            NEXT
         NEXT
      ENDIF
   ENDIF

   ErrorLevel( 0 )

   RETURN

/* Workflow translation from GNU Make to hbmk2:

      GNU Make       parameter  HB_MAKECMDGOALS  nAction                hbmk2 options
   -- -------------- ---------- ---------------- ---------------------- -------------------------
   #1 clean          clean      clean            _ACT_CLEAN             -clean
   #2 install        install    install          _ACT_INC_INST          -inc -instpath=
   #3 clean install  clean      clean install    _ACT_CLEAN             -clean
                     install    clean install    _ACT_INC_REBUILD_INST  -inc -instpath= -rebuild
   #4 install clean  install    install clean    _ACT_INC_INST          -inc -instpath=
                     clean      install clean    _ACT_CLEAN             -clean
   #5                all                         _ACT_INC               -inc
 */
PROCEDURE GNUMake( ... )
   LOCAL cBinDir
   LOCAL hProject
   LOCAL aProject
   LOCAL cProject
   LOCAL cDir

   LOCAL cOptions

   LOCAL cFilter
   LOCAL aFilter
   LOCAL lFilterNegative

   LOCAL aParams
   LOCAL aGNUMakeParams
   LOCAL nAction

   LOCAL cName
   LOCAL cItem

   LOCAL aPairList
   LOCAL lAnyAddons

   LOCAL aSortedList

   /* Check if the requirements are met and if we have anything to do */

   IF Empty( GetEnv( "HB_PLATFORM" ) ) .OR. ;
      Empty( GetEnv( "HB_COMPILER" ) ) .OR. ;
      Empty( GetEnv( "HB_HOST_BIN_DIR" ) )
      ErrorLevel( 9 )
      RETURN
   ENDIF

   cFilter := GetEnv( "HB_BUILD_CONTRIBS" )
   /* Compatibility */
   IF Empty( cFilter )
      cFilter := GetEnv( "HB_CONTRIBLIBS" )
   ENDIF

   IF ! Empty( cFilter )
      OutStd( "! HB_BUILD_CONTRIBS: " + cFilter + hb_eol() )
   ENDIF

   IF cFilter == "no"
      ErrorLevel( 0 )
      RETURN
   ENDIF

   /* Load list of addons. Convert it to our internal format */

   lAnyAddons := .F.
   FOR EACH cItem IN hb_ATokens( GetEnv( "HB_BUILD_ADDONS" ),, .T. )
      IF ! Empty( cItem )
         hb_FNameSplit( PathSepToSelf( cItem ), @cDir, @cName )
         s_hPackageList[ StrTran( DirDelPathSep( cDir ), "\", "/" ) ] := { "cFileName" => cName }
         lAnyAddons := .T.
      ENDIF
   NEXT

   /* Determine the mode of operation */

   aParams := hb_AParams()
   aGNUMakeParams := hb_ATokens( Lower( GetEnv( "HB_MAKECMDGOALS" ) ) )

   DO CASE
   CASE AScanL( aParams, "clean" ) > 0
      IF AScanL( aGNUMakeParams, "clean" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > AScanL( aGNUMakeParams, "clean" )
         nAction := _ACT_CLEAN
      ELSE
         nAction := _ACT_CLEAN
      ENDIF
   CASE AScanL( aParams, "install" ) > 0
      IF AScanL( aGNUMakeParams, "clean" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > 0 .AND. ;
         AScanL( aGNUMakeParams, "install" ) > AScanL( aGNUMakeParams, "clean" )
         /* Use rebuild mode. This is needed because the clean phase
            might not have been called previously by GNU Make, f.e.
            because hbrun or hbmk2 wasn't available. -rebuild is
            costless, so we do it to make sure to build cleanly.
            [vszakats] */
         nAction := _ACT_INC_REBUILD_INST
      ELSE
         nAction := _ACT_INC_INST
      ENDIF
   OTHERWISE
      nAction := _ACT_INC
   ENDCASE

   /* Parse filter */

   aFilter := iif( Empty( cFilter ), {}, hb_ATokens( cFilter,, .T. ) )
   IF Len( aFilter ) >= 1 .AND. aFilter[ 1 ] == "no"
      hb_ADel( aFilter, 1, .T. )
      lFilterNegative := .T.
   ELSE
      lFilterNegative := .F.
   ENDIF

   /* Clearing envvars that may interact with hbmk2 */

   /* Saving original install dirs to our own variables */
   hb_setenv( "_HB_BIN_INSTALL", GetEnv( "HB_BIN_INSTALL" ) )
   hb_setenv( "_HB_LIB_INSTALL", GetEnv( "HB_LIB_INSTALL" ) )
   hb_setenv( "_HB_DYN_INSTALL", GetEnv( "HB_DYN_INSTALL" ) )
   hb_setenv( "_HB_INC_INSTALL", GetEnv( "HB_INC_INSTALL" ) )

   /* Override hbmk2 autodetection */
   hb_setenv( "HB_INSTALL_PREFIX", s_cRoot )
   hb_setenv( "HB_BIN_INSTALL", s_cRoot + "bin/" + GetEnv( "HB_PLATFORM" ) + "/" + GetEnv( "HB_COMPILER" ) + GetEnv( "HB_BUILD_NAME" ) )
   hb_setenv( "HB_LIB_INSTALL", s_cRoot + "lib/" + GetEnv( "HB_PLATFORM" ) + "/" + GetEnv( "HB_COMPILER" ) + GetEnv( "HB_BUILD_NAME" ) )
   hb_setenv( "HB_DYN_INSTALL" )
   hb_setenv( "HB_INC_INSTALL", s_cRoot + "include" )

   /* Preprocessing */

   cBinDir := GetEnv( "HB_HOST_BIN_DIR" ) + hb_ps()

   OutStd( "! Calculating sorting order for contrib packages..." + hb_eol() )

   aPairList := {}

   FOR EACH aProject IN s_hPackageList
      FOR EACH hProject IN aProject
         call_hbmk2_hbinfo( cBinDir, s_cBase + aProject:__enumKey() + "/" + hProject[ "cFileName" ], hProject )
         DeptLinesToDeptPairList( aPairList, aProject:__enumKey(), hProject[ "aDept" ] )
      NEXT
   NEXT

   aSortedList := TopoSort( aPairList )

   /* Converting build options to hbmk2 options */

   hb_setenv( "_HB_BUILD_INSTALL" )

   cOptions := ""

   IF nAction == _ACT_CLEAN
      cOptions += " -clean"
   ELSE
      cOptions += " -inc"
      IF nAction == _ACT_INC_REBUILD_INST
         cOptions += " -rebuild"
      ENDIF
      IF nAction == _ACT_INC_INST .OR. ;
         nAction == _ACT_INC_REBUILD_INST
         hb_setenv( "_HB_BUILD_INSTALL", "yes" )
      ENDIF
   ENDIF

   /* Start building */

   OutStd( hb_StrFormat( "! Contribs %1$s...", hActions[ nAction ] ) + hb_eol() )

   FOR EACH cDir IN aSortedList DESCEND

      IF Empty( aFilter ) .OR. ;
         iif( lFilterNegative,;
            AScan( aFilter, {| tmp | tmp == cDir } ) == 0,;
            AScan( aFilter, {| tmp | tmp == cDir } ) > 0 )

         FOR EACH hProject IN s_hPackageList[ cDir ]

            IF hProject[ "cType" ] $ "hbhrb|hbppo"
               LOOP
            ENDIF

            cProject := s_cBase + cDir + "/" + hProject[ "cFileName" ]

            call_hbmk2( cBinDir, cProject, cOptions, "" )

            /* Highly experimental */
            IF hProject[ "cType" ] == "hblib" .AND. ;
               GetEnv( "HB_BUILD_CONTRIB_DLL" ) == "yes" .AND. ;
               hb_FileExists( PathSepToSelf( FNameExtSet( cProject, ".hbc" ) ) )

               call_hbmk2( cBinDir, cProject, cOptions, " -hbdyn -nohblib- -implib " + FNameExtSet( cProject, ".hbc" ) )
            ENDIF
         NEXT

         /* Compile documentation */
         IF nAction == _ACT_INC_INST .OR. ;
            nAction == _ACT_INC_REBUILD_INST
            mk_hbd( PathSepToSelf( cDir ) )
         ENDIF
      ELSE
         /* OutStd( hb_StrFormat( "! package '%1$s' skipped due to custom filter", cDir ) + hb_eol() ) */
      ENDIF
   NEXT

   OutStd( hb_eol() )
   IF lAnyAddons
      OutStd( "! Building of contrib and addon packages finished." + hb_eol() )
   ELSE
      OutStd( "! Building of contrib packages finished." + hb_eol() )
   ENDIF

   ErrorLevel( 0 )

   RETURN

STATIC FUNCTION call_hbmk2_hbinfo( cBinDir, cProject, hProject )
   LOCAL cStdOut
   LOCAL cDir
   LOCAL cName
   LOCAL tmp

   hProject[ "cType" ] := ""
   hProject[ "aDept" ] := {}
   hProject[ "lInc" ] := .F.

   IF hb_processRun( PathSepToSelf( cBinDir ) + "hbmk2 --hbinfo " + StrTran( cProject, "\", "/" ),, @cStdOut  ) == 0

      hProject[ "cType" ] := hbmk2_hbinfo_getitem( cStdOut, "targettype" )
      hProject[ "lInc" ] := ( hbmk2_hbinfo_getitem( cStdOut, "inc" ) == "yes" )

      FOR EACH tmp IN hb_ATokens( hbmk2_hbinfo_getitem( cStdOut, "hbctree" ), Chr( 10 ) )
         IF ! Empty( tmp )
            hb_FNameSplit( LTrim( tmp ), @cDir, @cName )
            AAdd( hProject[ "aDept" ], { "nDepth" => Len( tmp ) - Len( LTrim( tmp ) ),;
                                         "cDir" => cDir,;
                                         "cName" => cName } )
         ENDIF
      NEXT

      RETURN .T.
   ENDIF

   RETURN .F.

STATIC FUNCTION hbmk2_hbinfo_getitem( cString, cItem )
   LOCAL nPos

   IF ( nPos := At( cItem + "{{", cString ) ) > 0
      cString := SubStr( cString, nPos + Len( cItem + "{{" ) )
      IF ( nPos := At( "}}", cString ) ) > 0
         RETURN StrTran( Left( cString, nPos - 1 ), Chr( 13 ) )
      ENDIF
   ENDIF

   RETURN ""

STATIC FUNCTION call_hbmk2( cBinDir, cProject, cOptionsPre, cOptionsPost )
   LOCAL nErrorLevel

   /* Making sure that user settings do not interfere with the std build process. */
   hb_setenv( "HBMK_OPTIONS" )
   hb_setenv( "HARBOUR" )
   hb_setenv( "HARBOURCMD" )
   hb_setenv( "CLIPPER" )
   hb_setenv( "CLIPPERCMD" )

   nErrorLevel := mk_hb_processRun( PathSepToSelf( cBinDir ) + "hbmk2" +;
                                    " -quiet -lang=en -width=0" +;
                                    " @" + StrTran( s_cHome + "hbpre", "\", "/" ) +;
                                    cOptionsPre +;
                                    " " + StrTran( cProject, "\", "/" ) +;
                                    " @" + StrTran( s_cHome, "\", "/" ) + "hbpost" +;
                                    cOptionsPost )

   IF nErrorLevel != 0
      OutStd( hb_StrFormat( "! '%1$s' returned status: %2$s", cProject, hb_ntos( nErrorLevel ) ) + hb_eol() )
      RETURN .F.
   ENDIF

   RETURN .T.

STATIC FUNCTION mk_hb_processRun( cCommand )

   OutStd( cCommand + hb_eol() )

   RETURN iif( s_lTest, 0, hb_processRun( cCommand ) )

STATIC FUNCTION mk_hbd( cDir )
   LOCAL cName
   LOCAL tmp

   LOCAL aErrMsg
   LOCAL aEntry

   IF ! Empty( GetEnv( "HB_DOC_INSTALL" ) )

      cName := DirGetName( cDir )
      IF Empty( cName )
         cName := "harbour"
      ENDIF

      aErrMsg := {}
      aEntry := __hbdoc_LoadDir( cDir, cName, aErrMsg )

      FOR EACH tmp IN aErrMsg
         OutErr( hb_StrFormat( "! %1$s", tmp ) + hb_eol() )
      NEXT

      IF ! Empty( aEntry )
         cName := PathSepToSelf( GetEnv( "HB_DOC_INSTALL" ) ) + hb_ps() + cName + ".hbd"
         IF __hbdoc_SaveHBD( cName, aEntry )
            OutStd( "! Compiled documentation: " + cName + " <= " + cDir + hb_eol() )
            RETURN .T.
         ELSE
            OutErr( hb_StrFormat( "! Error: Saving '%1$s'", cName ) + hb_eol() )
         ENDIF
      ENDIF
   ENDIF

   RETURN .F.

STATIC FUNCTION AScanL( aArray, cString )
   RETURN AScan( aArray, {| tmp | Lower( tmp ) == cString } )

STATIC FUNCTION FNameDirGet( cFileName )
   LOCAL cDir

   hb_FNameSplit( cFileName, @cDir )

   RETURN cDir

STATIC FUNCTION FNameExtSet( cFileName, cExt )
   LOCAL cDir, cName

   hb_FNameSplit( cFileName, @cDir, @cName )

   RETURN hb_FNameMerge( cDir, cName, cExt )

STATIC FUNCTION DirGetName( cDir )
   LOCAL cName

   cDir := DirDelPathSep( cDir )

   hb_FNameSplit( cDir,, @cName )

   IF Empty( cName ) .OR. cName == "." .OR. cName == ".."
      RETURN ""
   ENDIF

   RETURN cName

STATIC FUNCTION DirDelPathSep( cDir )

   IF Empty( hb_osDriveSeparator() )
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps()
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ELSE
      DO WHILE Len( cDir ) > 1 .AND. Right( cDir, 1 ) == hb_ps() .AND. ;
               !( Right( cDir, 2 ) == hb_osDriveSeparator() + hb_ps() )
         cDir := hb_StrShrink( cDir, 1 )
      ENDDO
   ENDIF

   RETURN cDir

STATIC FUNCTION PathSepToSelf( cFileName )
#if defined( __PLATFORM__WINDOWS ) .OR. ;
    defined( __PLATFORM__DOS ) .OR. ;
    defined( __PLATFORM__OS2 )
   RETURN StrTran( cFileName, "/", "\" )
#else
   RETURN StrTran( cFileName, "\", "/" )
#endif

/* Convert indented list of line to tree / list of parent-child pairs */
STATIC PROCEDURE DeptLinesToDeptPairList( aPairList, cParent, aFlatTree )
   LOCAL hFlatTreeElement
   LOCAL hNode, hNewNode, tmp
   LOCAL nLevel, nDepth

   AddDeptPair( aPairList, "", cParent )

   hNode := { "child" => {}, "name" => cParent, "parent" => NIL }
   nLevel := 0
   FOR EACH hFlatTreeElement IN aFlatTree
      /* Min() protects against jumping more than one level down in one step */
      nDepth := Min( hFlatTreeElement[ "nDepth" ], nLevel + 1 )
      hNewNode := { "child" => {}, "name" => hFlatTreeElement[ "cName" ], "cargo" => hFlatTreeElement }
      IF nDepth > nLevel
         hNode := ATail( hNode[ "child" ] )
      ELSEIF nDepth < nLevel
         FOR tmp := nDepth + 1 TO nLevel
            hNode := hNode[ "parent" ]
         NEXT
      ENDIF
      hNewNode[ "parent" ] := hNode
      AAdd( hNode[ "child" ], hNewNode )
      nLevel := nDepth
      AddDeptPair( aPairList, hNewNode[ "parent" ][ "name" ], hNewNode[ "name" ] )
   NEXT

   RETURN

/* Add parent-child dependency to the list */
STATIC PROCEDURE AddDeptPair( aPairList, cParent, cChild )

   IF AScan( aPairList, {| tmp | tmp[ 1 ] == cParent .AND. tmp[ 2 ] == cChild } ) == 0
      AAdd( aPairList, { cParent, cChild } )
   ENDIF

   RETURN

/* Topological sort of the dependency graph */
STATIC FUNCTION TopoSort( aEdgeList )
   LOCAL aList := {}
   LOCAL hTopNodes := { => }

   LOCAL n, m
   LOCAL tmp

   hb_HKeepOrder( hTopNodes, .T. )

   FOR EACH n IN aEdgeList
      IF AScan( aEdgeList, {| tmp | tmp[ 2 ] == n[ 1 ] } ) == 0
         hTopNodes[ n[ 1 ] ] := NIL
      ENDIF
   NEXT

   DO WHILE ! Empty( hTopNodes )
      n := hb_HKeyAt( hTopNodes, 1 )
      hb_HDelAt( hTopNodes, 1 )

      IF ! Empty( n )
         AAdd( aList, n )
      ENDIF

      FOR EACH tmp IN aEdgeList
         IF tmp[ 1 ] == n
            m := tmp[ 2 ]
            tmp[ 1 ] := tmp[ 2 ] := NIL /* set to invalid value. TOOPT: Delete this member from list */
            IF AScan( aEdgeList, {| tmp | tmp[ 2 ] == m } ) == 0
               hTopNodes[ m ] := NIL
            ENDIF
         ENDIF
      NEXT
   ENDDO

   FOR EACH tmp IN aEdgeList
      IF !( tmp[ 1 ] == NIL .AND. tmp[ 2 ] == NIL )
         OutStd( hb_StrFormat( "! Warning: Circular reference in dependency tree (%1$s - %2$s)", tmp[ 1 ], tmp[ 2 ] ) + hb_eol() )
      ENDIF
   NEXT

   RETURN aList
