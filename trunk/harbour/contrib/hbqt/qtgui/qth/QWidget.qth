/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * QT Source Generator for Harbour
 *
 * Copyright 2009 Pritpal Bedi <pritpal@vouchcac.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA (or visit the web site http://www.gnu.org/).
 *
 * As a special exception, the Harbour Project gives permission for
 * additional uses of the text contained in its release of Harbour.
 *
 * The exception is that, if you link the Harbour libraries with other
 * files to produce an executable, this does not by itself cause the
 * resulting executable to be covered by the GNU General Public License.
 * Your use of that executable is in no way restricted on account of
 * linking the Harbour library code into it.
 *
 * This exception does not however invalidate any other reasons why
 * the executable file might be covered by the GNU General Public License.
 *
 * This exception applies only to the code released by the Harbour
 * Project under the name Harbour.  If you copy code from other
 * Harbour Project or Free Software Foundation releases into a copy of
 * Harbour, as the General Public License permits, the exception does
 * not apply to the code that you add in this way.  To avoid misleading
 * anyone as to the status of such modified files, you must delete
 * this exception notice from them.
 *
 * If you write modifications of your own for Harbour, it is your choice
 * whether to permit this exception to apply to your modifications.
 * If you do not wish that, delete this exception notice.
 *
 */
/*----------------------------------------------------------------------*/
;
;              Header File to Generate QT Wrapper Sources
;

<CLASS>
Inherit  = QObject, QPaintDevice
New      = pParent, nFlags
</CLASS>

<CODE>
#include <QtGui/QWidget>
#include <QtGui/QIcon>
#include <QtCore/QVariant>
#include <QtCore/QLocale>


/*
 * QWidget( QWidget * parent = 0, Qt::WindowFlags f = 0 )
 * ~QWidget ()
 */
HB_FUNC( QT_QWIDGET )
{
   if( hb_pcount() >= 1 && HB_ISPOINTER( 1 ) )
   {
      hb_retptr( new QWidget( hbqt_par_QWidget( 1 ), ( Qt::WindowFlags ) ( HB_ISNUM( 2 ) ? hb_parni( 2 ) : 0 ) ) );
   }
   else
   {
      hb_retptr( new QWidget() );
   }
}
</CODE>

<ENUMS>
enum RenderFlag { DrawWindowBackground, DrawChildren, IgnoreMask }
# From QPaintDevice : Parent Class
enum PaintDeviceMetric { PdmWidth, PdmHeight, PdmWidthMM, PdmHeightMM, ..., PdmPhysicalDpiY }
</ENUMS>

<PROTOS>
bool acceptDrops () const
// QString accessibleDescription () const
// QString accessibleName () const
QList<QAction *> actions () const
void activateWindow ()
void addAction ( QAction * action ){
   HBQT_GC_T_QWidget * q =  (HBQT_GC_T_QWidget *)hb_parptrGC( hbqt_gcFuncs(), 1 );
   HBQT_GC_T * p =  (HBQT_GC_T *)hb_parptrGC( hbqt_gcFuncs(), 2 );

   HB_TRACE( HB_TR_DEBUG, ( "Entering function QT_QWIDGET_ADDACTION()" ) );
   if( p && p->ph && q && q->ph )
   {
      HB_TRACE( HB_TR_DEBUG, ( "QT_QWIDGET_ADDACTION() Qt object: %p is attached to: %p", (void * )p->ph, (void *)q->ph ) );
      // p->bNew = HB_FALSE;  // The ownership of action is not transferred to this QWidget.
      ( q->ph )->addAction( ( QAction * ) p->ph );
   }
}
void addActions ( QList<QAction *> actions )
void adjustSize ()
bool autoFillBackground () const
QPalette::ColorRole backgroundRole () const
QSize baseSize () const

QWidget * childAt ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         hb_retptrGC( hbqt_gcAllocate_QWidget( ( p )->childAt( *hbqt_par_QPoint( 2 ) ), false ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         hb_retptrGC( hbqt_gcAllocate_QWidget( ( p )->childAt( hb_parni( 2 ), hb_parni( 3 ) ), false ) );
      }
   }
}
//QWidget * childAt ( int x, int y ) const
//QWidget * childAt ( const QPoint & p ) const

QRect childrenRect () const
QRegion childrenRegion () const
void clearFocus ()
void clearMask ()
QRect contentsRect () const
Qt::ContextMenuPolicy contextMenuPolicy () const
QCursor cursor () const
#
# non-portable
// WId effectiveWinId () const
void ensurePolished () const
Qt::FocusPolicy focusPolicy () const
QWidget * focusProxy () const
QWidget * focusWidget () const
const QFont & font () const
QFontInfo fontInfo () const
QFontMetrics fontMetrics () const
QPalette::ColorRole foregroundRole () const
QRect frameGeometry () const
QSize frameSize () const
const QRect & geometry () const
void getContentsMargins ( int * left, int * top, int * right, int * bottom ) const
# non-portable
// virtual HDC getDC () const
void grabKeyboard ()

void grabMouse ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->grabMouse( *hbqt_par_QCursor( 2 ) );
      }
      else
      {
         ( p )->grabMouse();
      }
   }
}
//void grabMouse ()
//void grabMouse ( const QCursor & cursor )

int grabShortcut ( const QKeySequence & key, Qt::ShortcutContext context = Qt::WindowShortcut )
// QGraphicsProxyWidget * graphicsProxyWidget () const
// bool hasEditFocus () const
bool hasFocus () const
bool hasMouseTracking () const
int height () const
virtual int heightForWidth ( int w ) const
// QInputContext * inputContext ()
virtual QVariant inputMethodQuery ( Qt::InputMethodQuery query ) const
void insertAction ( QAction * before, QAction * action )
void insertActions ( QAction * before, QList<QAction *> actions )
bool isActiveWindow () const
bool isAncestorOf ( const QWidget * child ) const
bool isEnabled () const
bool isEnabledTo ( QWidget * ancestor ) const
bool isFullScreen () const
bool isHidden () const
bool isMaximized () const
bool isMinimized () const
bool isModal () const
bool isVisible () const
bool isVisibleTo ( QWidget * ancestor ) const
bool isWindow () const
bool isWindowModified () const
QLayout * layout () const
Qt::LayoutDirection layoutDirection () const
QLocale locale () const
// Qt::HANDLE macCGHandle () const
// Qt::HANDLE macQDHandle () const
QPoint mapFrom ( QWidget * parent, const QPoint & pos ) const
QPoint mapFromGlobal ( const QPoint & pos ) const
QPoint mapFromParent ( const QPoint & pos ) const
QPoint mapTo ( QWidget * parent, const QPoint & pos ) const
QPoint mapToGlobal ( const QPoint & pos ) const
QPoint mapToParent ( const QPoint & pos ) const
QRegion mask () const
int maximumHeight () const
QSize maximumSize () const
int maximumWidth () const
int minimumHeight () const
QSize minimumSize () const
virtual QSize minimumSizeHint () const
int minimumWidth () const

void move ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->move( *hbqt_par_QPoint( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->move( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void move ( int x, int y )
//void move ( const QPoint & )

QWidget * nativeParentWidget () const
QWidget * nextInFocusChain () const
QRect normalGeometry () const
void overrideWindowFlags ( Qt::WindowFlags flags )
virtual QPaintEngine * paintEngine () const
const QPalette & palette () const
QWidget * parentWidget () const
QPoint pos () const
QRect rect () const
# non-portable
// virtual void releaseDC ( HDC hdc ) const
void releaseKeyboard ()
void releaseMouse ()
void releaseShortcut ( int id )
void removeAction ( QAction * action )
//void render ( QPaintDevice * target, const QPoint & targetOffset = QPoint(), const QRegion & sourceRegion = QRegion(), RenderFlags renderFlags = RenderFlags( DrawWindowBackground | DrawChildren ) )
//void render ( QPainter * painter, const QPoint & targetOffset = QPoint(), const QRegion & sourceRegion = QRegion(), RenderFlags renderFlags = RenderFlags( DrawWindowBackground | DrawChildren ) )

void repaint ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         HBQT_GC_T * q = ( HBQT_GC_T * ) hb_parptrGC( hbqt_gcFuncs(), 2 );

         if( q->type == HBQT_TYPE_QRect )
         {
            ( p )->repaint( *hbqt_par_QRect( 2 ) );
         }
         else if( q->type == HBQT_TYPE_QRegion )
         {
            ( p )->repaint( *hbqt_par_QRegion( 2 ) );
         }
      }
      else if( hb_pcount() == 5 && HB_ISNUM( 2 ) )
      {
         ( p )->repaint( hb_parni( 2 ), hb_parni( 3 ), hb_parni( 4 ), hb_parni( 5 ) );
      }
      else
      {
         ( p )->repaint();
      }
   }
}
//void repaint ( int x, int y, int w, int h )
//void repaint ( const QRect & rect )
//void repaint ( const QRegion & rgn )

void resize ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->resize( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->resize( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void resize ( int w, int h )
//void resize ( const QSize & )

bool restoreGeometry ( const QByteArray & geometry )
QByteArray saveGeometry () const

void scroll ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 4 && HB_ISNUM( 2 ) && HB_ISPOINTER( 4 ) )
      {
         ( p )->scroll( hb_parni( 2 ), hb_parni( 3 ), *hbqt_par_QRect( 4 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->scroll( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void scroll ( int dx, int dy )
//void scroll ( int dx, int dy, const QRect & r )

void setAcceptDrops ( bool on )
// void setAccessibleDescription ( const QString & description )
// void setAccessibleName ( const QString & name )
void setAttribute ( Qt::WidgetAttribute attribute, bool on = true )
void setAutoFillBackground ( bool enabled )
void setBackgroundRole ( QPalette::ColorRole role )

void setBaseSize ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setBaseSize( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setBaseSize( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void setBaseSize ( const QSize & )
//void setBaseSize ( int basew, int baseh )

void setContentsMargins ( int left, int top, int right, int bottom )
void setContextMenuPolicy ( Qt::ContextMenuPolicy policy )
void setCursor ( const QCursor & )
// void setEditFocus ( bool enable )
void setFixedHeight ( int h )

void setFixedSize ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setFixedSize( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setFixedSize( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void setFixedSize ( const QSize & s )
//void setFixedSize ( int w, int h )

void setFixedWidth ( int w )

void setFocus ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISNUM( 2 ) )
      {
         ( p )->setFocus( ( Qt::FocusReason ) hb_parni( 2 ) );
      }
      else
      {
         ( p )->setFocus();
      }
   }
}
//void setFocus ( Qt::FocusReason reason )

void setFocusPolicy ( Qt::FocusPolicy policy )
void setFocusProxy ( QWidget * w )
void setFont ( const QFont & )
void setForegroundRole ( QPalette::ColorRole role )

void setGeometry ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setGeometry( *hbqt_par_QRect( 2 ) );
      }
      else if( hb_pcount() == 5 && HB_ISNUM( 2 ) )
      {
         ( p )->setGeometry( hb_parni( 2 ), hb_parni( 3 ), hb_parni( 4 ), hb_parni( 5 ) );
      }
   }
}
//void setGeometry ( const QRect & )
//void setGeometry ( int x, int y, int w, int h )

// void setInputContext ( QInputContext * context )
void setLayout ( QLayout * layout )
void setLayoutDirection ( Qt::LayoutDirection direction )
void setLocale ( const QLocale & locale )

void setMask ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      HBQT_GC_T * q = ( HBQT_GC_T * ) hb_parptrGC( hbqt_gcFuncs(), 2 );

      if( q->type == HBQT_TYPE_QBitmap )
      {
         ( p )->setMask( *hbqt_par_QBitmap( 2 ) );
      }
      else if( q->type == HBQT_TYPE_QRegion )
      {
         ( p )->setMask( *hbqt_par_QRegion( 2 ) );
      }
   }
}
//void setMask ( const QBitmap & bitmap )
//void setMask ( const QRegion & region )

void setMaximumHeight ( int maxh )

void setMaximumSize ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setMaximumSize( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setMaximumSize( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void setMaximumSize ( const QSize & )
//void setMaximumSize ( int maxw, int maxh )

void setMaximumWidth ( int maxw )
void setMinimumHeight ( int minh )

void setMinimumSize ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setMinimumSize( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setMinimumSize( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void setMinimumSize ( const QSize & )
//void setMinimumSize ( int minw, int minh )

void setMinimumWidth ( int minw )
void setMouseTracking ( bool enable )
void setPalette ( const QPalette & )

void setParent ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setParent( hbqt_par_QWidget( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISPOINTER( 2 ) && HB_ISNUM( 3 ) )
      {
         ( p )->setParent( hbqt_par_QWidget( 2 ), ( Qt::WindowFlags ) hb_parni( 3 ) );
      }
   }
}
//void setParent ( QWidget * parent )
//void setParent ( QWidget * parent, Qt::WindowFlags f )

void setShortcutAutoRepeat ( int id, bool enable = true )
void setShortcutEnabled ( int id, bool enable = true )

void setSizeIncrement ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setSizeIncrement( *hbqt_par_QSize( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setSizeIncrement( hb_parni( 2 ), hb_parni( 3 ) );
      }
   }
}
//void setSizeIncrement ( const QSize & )
//void setSizeIncrement ( int w, int h )

void setSizePolicy ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         ( p )->setSizePolicy( *hbqt_par_QSizePolicy( 2 ) );
      }
      else if( hb_pcount() == 3 && HB_ISNUM( 2 ) )
      {
         ( p )->setSizePolicy( ( QSizePolicy::Policy ) hb_parni( 2 ), ( QSizePolicy::Policy ) hb_parni( 3 ) );
      }
   }
}
//void setSizePolicy ( const QSizePolicy & policy )
//void setSizePolicy ( QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical )

void setStatusTip ( const QString & )
void setStyle ( QStyle * style )
void setToolTip ( const QString & )
void setUpdatesEnabled ( bool enable )
void setWhatsThis ( const QString & )
void setWindowFilePath ( const QString & filePath )
void setWindowFlags ( Qt::WindowFlags type )
void setWindowIcon ( const QIcon & icon )
void setWindowIconText ( const QString & )
void setWindowModality ( Qt::WindowModality windowModality )
void setWindowOpacity ( qreal level )
void setWindowRole ( const QString & role )
void setWindowState ( Qt::WindowStates windowState )
// void setWindowSurface ( QWindowSurface * surface )
QSize size () const
virtual QSize sizeHint () const
QSize sizeIncrement () const
QSizePolicy sizePolicy () const
void stackUnder ( QWidget * w )
QString statusTip () const
QStyle * style () const
QString styleSheet () const
bool testAttribute ( Qt::WidgetAttribute attribute ) const
QString toolTip () const
bool underMouse () const
void unsetCursor ()
void unsetLayoutDirection ()
void unsetLocale ()

void update ( ... ){
   QWidget * p = hbqt_par_QWidget( 1 );
   if( p )
   {
      if( hb_pcount() == 2 && HB_ISPOINTER( 2 ) )
      {
         HBQT_GC_T * q = ( HBQT_GC_T * ) hb_parptrGC( hbqt_gcFuncs(), 2 );

         if( q->type == HBQT_TYPE_QRect )
         {
            ( p )->update( *hbqt_par_QRect( 2 ) );
         }
         else if( q->type == HBQT_TYPE_QRegion )
         {
            ( p )->update( *hbqt_par_QRegion( 2 ) );
         }
      }
      else if( hb_pcount() == 5 && HB_ISNUM( 2 ) )
      {
         ( p )->update( hb_parni( 2 ), hb_parni( 3 ), hb_parni( 4 ), hb_parni( 5 ) );
      }
      else
      {
         ( p )->update();
      }
   }
}
//void update ( int x, int y, int w, int h )
//void update ( const QRect & rect )
//void update ( const QRegion & rgn )

void updateGeometry ()
bool updatesEnabled () const
QRegion visibleRegion () const
QString whatsThis () const
int width () const
//WId winId () const
QWidget * window () const
QString windowFilePath () const
Qt::WindowFlags windowFlags () const
QIcon windowIcon () const
QString windowIconText () const
Qt::WindowModality windowModality () const
qreal windowOpacity () const
QString windowRole () const
Qt::WindowStates windowState () const
// QWindowSurface * windowSurface () const   (preliminary)
QString windowTitle () const
Qt::WindowType windowType () const
int x () const
//Qt::HANDLE x11PictureHandle () const
int y () const

//QWidget * find ( WId id )
QWidget * keyboardGrabber ()
QWidget * mouseGrabber ()
void setTabOrder ( QWidget * first, QWidget * second )
</PROTOS>

<SLOTS>
bool close ()
void hide ()
void lower ()
void raise ()
//void repaint ()
void setDisabled ( bool disable )
void setEnabled ( bool enable )
//void setFocus ()
void setHidden ( bool hidden )
void setStyleSheet ( const QString & styleSheet )
virtual void setVisible ( bool visible )
void setWindowModified ( bool modified )
void setWindowTitle ( const QString & title )
void show ()
void showFullScreen ()
void showMaximized ()
void showMinimized ()
void showNormal ()
//void update ()
</SLOTS>

<SIGNALS>
void clicked ( bool checked = false )
void pressed ()
void released ()
void toggled ( bool checked )
</SIGNALS>
