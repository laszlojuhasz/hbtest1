/*
 * $Id$
 */

/*
 * hbmk2 plugin script, implementing support for QT specific features
 *
 * Copyright 2010 Viktor Szakats (harbour.01 syenar.hu)
 * Copyright 2010 Pritpal Bedi <bedipritpal@hotmail.com> (qth->prg/cpp generator and hbqtui_gen_prg())
 * www - http://harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

#pragma warninglevel=3
#pragma -km+
#pragma -ko+

#include "directry.ch"
#include "hbclass.ch"

#define I_( x )                 hb_i18n_gettext( x )
#define  _GEN_TRACE_

#if defined( __HBSCRIPT__HBMK )

FUNCTION hbmk2_plugin_qt( hbmk2 )
   LOCAL cRetVal := ""

   LOCAL cSrc
   LOCAL cDst
   LOCAL tSrc
   LOCAL tDst

   LOCAL cDstCPP, cDstDOC
   LOCAL tDstCPP

   LOCAL cTmp
   LOCAL cPRG

   LOCAL cCommand
   LOCAL nError
   LOCAL lBuildIt

   SWITCH hbmk2[ "cSTATE" ]
   CASE "init"

      hbmk2_Register_Input_File_Extension( hbmk2, ".qrc" )
      hbmk2_Register_Input_File_Extension( hbmk2, ".ui" )
      hbmk2_Register_Input_File_Extension( hbmk2, ".hpp" )
      hbmk2_Register_Input_File_Extension( hbmk2, ".h" )
      hbmk2_Register_Input_File_Extension( hbmk2, ".qth" )

      EXIT

   CASE "pre_all"

      /* Gather input parameters */

      hbmk2[ "vars" ][ "aQRC_Src" ] := {}
      hbmk2[ "vars" ][ "aUIC_Src" ] := {}
      hbmk2[ "vars" ][ "aMOC_Src" ] := {}
      hbmk2[ "vars" ][ "aQTH_Src" ] := {}

      hbmk2[ "vars" ][ "qtmodule" ] := ""
      hbmk2[ "vars" ][ "qtver" ] := ""
      hbmk2[ "vars" ][ "qthdocdir" ] := ""

      FOR EACH cSrc IN hbmk2[ "params" ]
         IF Left( cSrc, 1 ) == "-"
            DO CASE
            CASE Left( cSrc, Len( "-qtver=" ) ) == "-qtver="
               hbmk2[ "vars" ][ "qtver" ] := SubStr( cSrc, Len( "-qtver=" ) + 1 )
            CASE Left( cSrc, Len( "-qtmodule=" ) ) == "-qtmodule="
               hbmk2[ "vars" ][ "qtmodule" ] := SubStr( cSrc, Len( "-qtmodule=" ) + 1 )
            CASE Left( cSrc, Len( "-qthdocdir=" ) ) == "-qthdocdir="
               hbmk2[ "vars" ][ "qthdocdir" ] := SubStr( cSrc, Len( "-qthdocdir=" ) + 1 )
            ENDCASE
         ELSE
            SWITCH Lower( hb_FNameExt( cSrc ) )
            CASE ".qrc"
               AAdd( hbmk2[ "vars" ][ "aQRC_Src" ], cSrc )
               EXIT
            CASE ".ui"
               AAdd( hbmk2[ "vars" ][ "aUIC_Src" ], cSrc )
               EXIT
            CASE ".hpp"
            CASE ".h"
               AAdd( hbmk2[ "vars" ][ "aMOC_Src" ], cSrc )
               EXIT
            CASE ".qth"
               AAdd( hbmk2[ "vars" ][ "aQTH_Src" ], cSrc )
               EXIT
            ENDSWITCH
         ENDIF
      NEXT

      /* Create output file lists */

      hbmk2[ "vars" ][ "aQRC_Dst" ] := {}
      hbmk2[ "vars" ][ "aQRC_PRG" ] := {}
      FOR EACH cSrc IN hbmk2[ "vars" ][ "aQRC_Src" ]
         cDst := hbmk2_FNameDirExtSet( "rcc_" + hb_FNameName( cSrc ), hbmk2[ "cWorkDir" ], ".qrb" )
         AAdd( hbmk2[ "vars" ][ "aQRC_Dst" ], cDst )
         cDst := hbmk2_FNameDirExtSet( "rcc_" + hb_FNameName( cSrc ), hbmk2[ "cWorkDir" ], ".prg" )
         AAdd( hbmk2[ "vars" ][ "aQRC_PRG" ], cDst )
         hbmk2_AddInput_PRG( hbmk2, cDst )
      NEXT

      hbmk2[ "vars" ][ "aUIC_Dst" ] := {}
      FOR EACH cSrc IN hbmk2[ "vars" ][ "aUIC_Src" ]
         cDst := hbmk2_FNameDirExtSet( "uic_" + hb_FNameName( cSrc ), hbmk2[ "cWorkDir" ], ".prg" )
         AAdd( hbmk2[ "vars" ][ "aUIC_Dst" ], cDst )
         hbmk2_AddInput_PRG( hbmk2, cDst )
      NEXT

      hbmk2[ "vars" ][ "aMOC_Dst" ] := {}
      FOR EACH cSrc IN hbmk2[ "vars" ][ "aMOC_Src" ]
         cDst := hbmk2_FNameDirExtSet( "moc_" + hb_FNameName( cSrc ), hbmk2[ "cWorkDir" ], ".cpp" )
         AAdd( hbmk2[ "vars" ][ "aMOC_Dst" ], cDst )
         hbmk2_AddInput_CPP( hbmk2, cDst )
      NEXT

      hbmk2[ "vars" ][ "aQTH_CPP" ] := {}
      hbmk2[ "vars" ][ "aQTH_DOC" ] := {}
      FOR EACH cSrc IN hbmk2[ "vars" ][ "aQTH_Src" ]
         cDst := hbmk2_FNameDirExtSet( hb_FNameName( cSrc ), hbmk2[ "cWorkDir" ], ".cpp" )
         AAdd( hbmk2[ "vars" ][ "aQTH_CPP" ], cDst )
         hbmk2_AddInput_CPP( hbmk2, cDst )
         cDst := hb_PathNormalize( hbmk2_FNameDirExtSet( "class_" + Lower( hb_FNameName( cSrc ) ), hb_FNameDir( cSrc ) + hbmk2[ "vars" ][ "qthdocdir" ] + "en" + hb_ps(), ".txt" ) )
         AAdd( hbmk2[ "vars" ][ "aQTH_DOC" ], cDst )
      NEXT

      /* Detect tool locations */

      IF ! hbmk2[ "lCLEAN" ]
         IF ! Empty( hbmk2[ "vars" ][ "aQRC_Src" ] )
            hbmk2[ "vars" ][ "cRCC_BIN" ] := qt_tool_detect( hbmk2, "rcc", "RCC_BIN", .F. )
            IF Empty( hbmk2[ "vars" ][ "cRCC_BIN" ] )
               cRetVal := I_( "Required QT tool not found" )
            ENDIF
         ENDIF
         IF ! Empty( hbmk2[ "vars" ][ "aUIC_Src" ] )
            hbmk2[ "vars" ][ "cUIC_BIN" ] := qt_tool_detect( hbmk2, "uic", "UIC_BIN" )
            IF Empty( hbmk2[ "vars" ][ "cUIC_BIN" ] )
               cRetVal := I_( "Required QT tool not found" )
            ENDIF
         ENDIF
         IF ! Empty( hbmk2[ "vars" ][ "aMOC_Src" ] )
            hbmk2[ "vars" ][ "cMOC_BIN" ] := qt_tool_detect( hbmk2, "moc", "MOC_BIN" )
            IF Empty( hbmk2[ "vars" ][ "cMOC_BIN" ] )
               cRetVal := I_( "Required QT tool not found" )
            ENDIF
         ENDIF
      ENDIF

      EXIT

   CASE "pre_prg"

      IF ! hbmk2[ "lCLEAN" ] .AND. ;
         ! Empty( hbmk2[ "vars" ][ "aQRC_Src" ] )

         IF ! Empty( hbmk2[ "vars" ][ "cRCC_BIN" ] )

            /* Execute 'rcc' commands on input files */

            FOR EACH cSrc, cDst, cPRG IN hbmk2[ "vars" ][ "aQRC_Src" ], hbmk2[ "vars" ][ "aQRC_Dst" ], hbmk2[ "vars" ][ "aQRC_PRG" ]

               IF hbmk2[ "lINC" ] .AND. ! hbmk2[ "lREBUILD" ]
                  lBuildIt := ! hb_FGetDateTime( cDst, @tDst ) .OR. ;
                              ! hb_FGetDateTime( cSrc, @tSrc ) .OR. ;
                              tSrc > tDst
               ELSE
                  lBuildIt := .T.
               ENDIF

               IF lBuildIt

                  cCommand := hbmk2[ "vars" ][ "cRCC_BIN" ] +;
                              " -binary" +;
                              " " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cSrc ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] ) +;
                              " -o " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cDst ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] )

                  IF hbmk2[ "lTRACE" ]
                     IF ! hbmk2[ "lQUIET" ]
                        hbmk2_OutStd( hbmk2, I_( "'rcc' command:" ) )
                     ENDIF
                     hbmk2_OutStdRaw( cCommand )
                  ENDIF

                  IF ! hbmk2[ "lDONTEXEC" ]
                     IF ( nError := hb_processRun( cCommand ) ) != 0
                        hbmk2_OutErr( hbmk2, hb_StrFormat( I_( "Error: Running 'rcc' executable. %1$s" ), hb_ntos( nError ) ) )
                        IF ! hbmk2[ "lQUIET" ]
                           hbmk2_OutErrRaw( cCommand )
                        ENDIF
                        IF ! hbmk2[ "lIGNOREERROR" ]
                           cRetVal := "error"
                           EXIT
                        ENDIF
                     ELSE
                        /* Create little .prg stub which includes the binary */
                        cTmp := "/* WARNING: Automatically generated source file. DO NOT EDIT! */" + hb_eol() +;
                                hb_eol() +;
                                "#pragma -km+" + hb_eol() +;
                                hb_eol() +;
                                "FUNCTION hbqtres_" + hbmk2_FNameToSymbol( hb_FNameName( cSrc ) ) + "()" + hb_eol() +;
                                "   #pragma __binarystreaminclude " + Chr( 34 ) + hb_FNameNameExt( cDst ) + Chr( 34 ) + "|RETURN %s" + hb_eol()

                        IF ! hb_MemoWrit( cPRG, cTmp )
                           hbmk2_OutErr( hbmk2, hb_StrFormat( "Error: Cannot create file: %1$s", cPRG ) )
                           IF ! hbmk2[ "lIGNOREERROR" ]
                              cRetVal := "error"
                              EXIT
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            NEXT
         ENDIF
      ENDIF

      IF ! hbmk2[ "lCLEAN" ] .AND. ;
         ! Empty( hbmk2[ "vars" ][ "aUIC_Src" ] )

         IF ! Empty( hbmk2[ "vars" ][ "cUIC_BIN" ] )

            /* Execute 'uic' commands on input files */

            FOR EACH cSrc, cDst IN hbmk2[ "vars" ][ "aUIC_Src" ], hbmk2[ "vars" ][ "aUIC_Dst" ]

               IF hbmk2[ "lINC" ] .AND. ! hbmk2[ "lREBUILD" ]
                  lBuildIt := ! hb_FGetDateTime( cDst, @tDst ) .OR. ;
                              ! hb_FGetDateTime( cSrc, @tSrc ) .OR. ;
                              tSrc > tDst
               ELSE
                  lBuildIt := .T.
               ENDIF

               IF lBuildIt

                  FClose( hb_FTempCreateEx( @cTmp ) )

                  cCommand := hbmk2[ "vars" ][ "cUIC_BIN" ] +;
                              " " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cSrc ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] ) +;
                              " -o " + hbmk2_FNameEscape( cTmp, hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] )

                  IF hbmk2[ "lTRACE" ]
                     IF ! hbmk2[ "lQUIET" ]
                        hbmk2_OutStd( hbmk2, I_( "'uic' command:" ) )
                     ENDIF
                     hbmk2_OutStdRaw( cCommand )
                  ENDIF

                  IF ! hbmk2[ "lDONTEXEC" ]
                     IF ( nError := hb_processRun( cCommand ) ) != 0
                        hbmk2_OutErr( hbmk2, hb_StrFormat( I_( "Error: Running 'uic' executable. %1$s" ), hb_ntos( nError ) ) )
                        IF ! hbmk2[ "lQUIET" ]
                           hbmk2_OutErrRaw( cCommand )
                        ENDIF
                        IF ! hbmk2[ "lIGNOREERROR" ]
                           FErase( cTmp )
                           cRetVal := "error"
                           EXIT
                        ENDIF
                     ELSE
                        IF ! uic_to_prg( hbmk2, cTmp, cDst, hbmk2_FNameToSymbol( hb_FNameName( cSrc ) ) )
                           IF ! hbmk2[ "lIGNOREERROR" ]
                              FErase( cTmp )
                              cRetVal := "error"
                              EXIT
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
                  FErase( cTmp )
               ENDIF
            NEXT
         ENDIF
      ENDIF

      EXIT

   CASE "pre_c"

      IF ! hbmk2[ "lCLEAN" ] .AND. ;
         ! Empty( hbmk2[ "vars" ][ "aQTH_Src" ] )

         IF ! Empty( hbmk2[ "vars" ][ "qtmodule" ] ) .AND. ;
            ! Empty( hbmk2[ "vars" ][ "qtver" ] )

            FOR EACH cSrc, cDstCPP, cDstDOC IN hbmk2[ "vars" ][ "aQTH_Src" ], hbmk2[ "vars" ][ "aQTH_CPP" ], hbmk2[ "vars" ][ "aQTH_DOC" ]

               IF hbmk2[ "lINC" ] .AND. ! hbmk2[ "lREBUILD" ]
                  lBuildIt := ! hb_FGetDateTime( cDstCPP, @tDstCPP ) .OR. ;
                              ! hb_FGetDateTime( cSrc, @tSrc ) .OR. ;
                              tSrc > tDstCPP
               ELSE
                  lBuildIt := .T.
               ENDIF

               IF lBuildIt
                  IF ! hbmk2[ "lDONTEXEC" ]
                     IF ! qth_to_src( cSrc, cDstCPP, cDstDOC, hbmk2[ "vars" ][ "qtmodule" ], hbmk2[ "vars" ][ "qtver" ] )
                        IF ! hbmk2[ "lIGNOREERROR" ]
                           cRetVal := "error"
                           EXIT
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            NEXT
         ELSE
            hbmk2_OutErr( hbmk2, I_( "Error: Qt module or version not specified." ) )
            cRetVal := "error"
         ENDIF
      ENDIF

      IF ! hbmk2[ "lCLEAN" ] .AND. ;
         ! Empty( hbmk2[ "vars" ][ "aMOC_Src" ] )

         IF ! Empty( hbmk2[ "vars" ][ "cMOC_BIN" ] )

            /* Execute 'moc' commands on input files */

            FOR EACH cSrc, cDst IN hbmk2[ "vars" ][ "aMOC_Src" ], hbmk2[ "vars" ][ "aMOC_Dst" ]

               IF hbmk2[ "lINC" ] .AND. ! hbmk2[ "lREBUILD" ]
                  lBuildIt := ! hb_FGetDateTime( cDst, @tDst ) .OR. ;
                              ! hb_FGetDateTime( cSrc, @tSrc ) .OR. ;
                              tSrc > tDst
               ELSE
                  lBuildIt := .T.
               ENDIF

               IF lBuildIt

                  cCommand := hbmk2[ "vars" ][ "cMOC_BIN" ] +;
                              " " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cSrc ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] ) +;
                              " -o " + hbmk2_FNameEscape( hbmk2_PathSepToTarget( hbmk2, cDst ), hbmk2[ "nCmd_Esc" ], hbmk2[ "nCmd_FNF" ] )

                  IF hbmk2[ "lTRACE" ]
                     IF ! hbmk2[ "lQUIET" ]
                        hbmk2_OutStd( hbmk2, I_( "'moc' command:" ) )
                     ENDIF
                     hbmk2_OutStdRaw( cCommand )
                  ENDIF

                  IF ! hbmk2[ "lDONTEXEC" ] .AND. ( nError := hb_processRun( cCommand ) ) != 0
                     hbmk2_OutErr( hbmk2, hb_StrFormat( I_( "Error: Running 'moc' executable. %1$s" ), hb_ntos( nError ) ) )
                     IF ! hbmk2[ "lQUIET" ]
                        hbmk2_OutErrRaw( cCommand )
                     ENDIF
                     IF ! hbmk2[ "lIGNOREERROR" ]
                        cRetVal := "error"
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
            NEXT
         ENDIF
      ENDIF

      EXIT

   CASE "post_all"

      IF ! hbmk2[ "lINC" ] .OR. hbmk2[ "lCLEAN" ]
         AEval( hbmk2[ "vars" ][ "aQRC_Dst" ], {| tmp | FErase( tmp ) } )
         AEval( hbmk2[ "vars" ][ "aQRC_PRG" ], {| tmp | FErase( tmp ) } )
         AEval( hbmk2[ "vars" ][ "aUIC_Dst" ], {| tmp | FErase( tmp ) } )
         AEval( hbmk2[ "vars" ][ "aMOC_Dst" ], {| tmp | FErase( tmp ) } )
         AEval( hbmk2[ "vars" ][ "aQTH_CPP" ], {| tmp | FErase( tmp ) } )
         AEval( hbmk2[ "vars" ][ "aQTH_DOC" ], {| tmp | FErase( tmp ) } )
      ENDIF

      EXIT

   ENDSWITCH

   RETURN cRetVal

STATIC FUNCTION qt_tool_detect( hbmk2, cName, cEnvQT, lPostfix )
   LOCAL cBIN
   LOCAL aEnvList
   LOCAL cStdErr

   IF ! hb_isLogical( lPostfix )
      lPostfix := .T.
   ENDIF

   IF lPostfix
      aEnvList := { "HB_QTPATH", "HB_QTPOSTFIX" }
   ELSE
      aEnvList := { "HB_QTPATH" }
   ENDIF

   cBIN := GetEnv( cEnvQT )
   IF Empty( cBIN )
      IF lPostfix
         cName += GetEnv( "HB_QTPOSTFIX" )
      ENDIF
      IF Empty( GetEnv( "HB_QTPATH" ) ) .OR. ;
         ! hb_FileExists( cBIN := GetEnv( "HB_QTPATH" ) + cName )

         cBIN := ""
         IF hbmk2[ "cPLAT" ] $ "win|os2"

            hb_AIns( aEnvList, 1, "HB_WITH_QT", .T. )

            IF ! Empty( GetEnv( "HB_WITH_QT" ) )

               IF GetEnv( "HB_W_ITH_QT" ) == "no"
                  /* Return silently. It shall fail at dependency detection inside hbmk2 */
                  RETURN NIL
               ELSE
                  IF ! hb_FileExists( cBIN := hb_PathNormalize( GetEnv( "HB_WITH_QT" ) + "\..\bin\" + cName + ".exe" ) )
                     hbmk2_OutErr( hbmk2, hb_StrFormat( "Warning: HB_WITH_QT points to incomplete QT installation. '%1$s' executable not found.", cName ) )
                     cBIN := ""
                  ENDIF
               ENDIF
            ELSE
               cBIN := hb_DirSepAdd( hb_DirBase() ) + cName + ".exe"
               IF ! hb_FileExists( cBIN )
                  cBIN := ""
               ENDIF
            ENDIF
         ENDIF

         IF Empty( cBIN )
            cBIN := hbmk2_FindInPath( cName, GetEnv( "PATH" ) + hb_osPathListSeparator() + "/opt/qtsdk/qt/bin" )
            IF Empty( cBIN )
               hbmk2_OutErr( hbmk2, hb_StrFormat( "%1$s not set, could not autodetect '%2$s' executable", hbmk2_ArrayToList( aEnvList, ", " ), cName ) )
               RETURN NIL
            ENDIF
         ENDIF
      ENDIF
      IF hbmk2[ "lINFO" ]
         cStdErr := ""
         IF ! hbmk2[ "lDONTEXEC" ]
            hb_processRun( cBIN + " -v",,, @cStdErr )
            IF ! Empty( cStdErr )
               cStdErr := " [" + StrTran( StrTran( cStdErr, Chr( 13 ) ), Chr( 10 ) ) + "]"
            ENDIF
         ENDIF
         hbmk2_OutStd( hbmk2, hb_StrFormat( "Using QT '%1$s' executable: %2$s%3$s (autodetected)", cName, cBIN, cStdErr ) )
      ENDIF
   ENDIF

   RETURN cBIN

#else

/* Standalone test code conversions */
PROCEDURE Main( cSrc )
   LOCAL cTmp
   LOCAL nError
   LOCAL cExt
   LOCAL aFile
   LOCAL cFN

   IF cSrc != NIL

      hb_FNameSplit( cSrc,,, @cExt )

      SWITCH Lower( cExt )
      CASE ".ui"

         FClose( hb_FTempCreateEx( @cTmp ) )

         IF ( nError := hb_processRun( "uic " + cSrc + " -o " + cTmp ) ) == 0
            IF ! uic_to_prg( NIL, cTmp, cSrc + ".prg", "TEST" )
               nError := 9
            ENDIF
         ELSE
            OutErr( "Error: Calling 'uic' tool: " + hb_ntos( nError ) + hb_eol() )
         ENDIF

         FErase( cTmp )
         EXIT

      CASE ".qth"

         FOR EACH aFile IN Directory( cSrc )
            cFN := hb_FNameMerge( FNameDirGet( cSrc ), aFile[ F_NAME ] )
            qth_to_src( cFN, cFN + ".cpp", cFN + ".txt", "QtModule", "0x040500" )
         NEXT

         EXIT

      ENDSWITCH
   ELSE
      OutErr( "Missing parameter. Call with: <input>" + hb_eol() )
      nError := 8
   ENDIF

   ErrorLevel( nError )

   RETURN

STATIC FUNCTION FNameDirGet( cFileName )
   LOCAL cDir

   hb_FNameSplit( cFileName, @cDir )

   RETURN cDir

STATIC FUNCTION hbmk2_OutStd( hbmk2, ... )
   HB_SYMBOL_UNUSED( hbmk2 )
   RETURN OutStd( ... )

STATIC FUNCTION hbmk2_OutErr( hbmk2, ... )
   HB_SYMBOL_UNUSED( hbmk2 )
   RETURN OutErr( ... )

#endif

/* ----------------------------------------------------------------------- */

STATIC FUNCTION uic_to_prg( hbmk2, cFileNameSrc, cFileNameDst, cName )
   LOCAL aLinesPRG
   LOCAL cFile

   IF hb_FileExists( cFileNameSrc )
      IF ! Empty( cFile := hb_MemoRead( cFileNameSrc ) )
         IF ! Empty( aLinesPRG := hbqtui_gen_prg( cFile, "hbqtui_" + cName ) )
            cFile := ""
            AEval( aLinesPRG, {| cLine | cFile += cLine + hb_eol() } )
            IF hb_MemoWrit( cFileNameDst, cFile )
               RETURN .T.
            ELSE
               hbmk2_OutErr( hbmk2, hb_StrFormat( "Error: Cannot create file: %1$s", cFileNameDst ) )
            ENDIF
         ELSE
            hbmk2_OutErr( hbmk2, hb_StrFormat( "Error: Intermediate file (%1$s) is not an .uic file.", cFileNameSrc ) )
         ENDIF
      ELSE
         hbmk2_OutErr( hbmk2, hb_StrFormat( "Error: Intermediate file (%1$s) empty or cannot be read.", cFileNameSrc ) )
      ENDIF
   ELSE
      hbmk2_OutErr( hbmk2, hb_StrFormat( "Error: Cannot find intermediate file: %1$s", cFileNameSrc ) )
   ENDIF

   RETURN .F.

/* ----------------------------------------------------------------------- */

#define HBQTUI_STRINGIFY( cStr )    '"' + cStr + '"'
#define HBQTUI_PAD_30( cStr )       PadR( cStr, Max( Len( cStr ), 35 ) )
#define HBQTUI_STRIP_SQ( cStr )     StrTran( StrTran( StrTran( StrTran( s, "[", " " ), "]", " " ), "\n", " " ), Chr( 10 ), " " )

STATIC FUNCTION hbqtui_gen_prg( cFile, cFuncName )
   LOCAL s
   LOCAL n
   LOCAL n1
   LOCAL cCls
   LOCAL cNam
   LOCAL lCreateFinished
   LOCAL cMCls
   LOCAL cMNam
   LOCAL cText
   LOCAL cCmd
   LOCAL aReg
   LOCAL item
   LOCAL aLinesPRG

   LOCAL regEx := hb_regexComp( "\bQ[A-Za-z_]+ \b" )

   LOCAL aLines := hb_ATokens( StrTran( cFile, Chr( 13 ) ), Chr( 10 ) )

   LOCAL aWidgets := {}
   LOCAL aCommands := {}

   lCreateFinished := .F.

   /* Pullout the widget */
   n := AScan( aLines, {| e | "void setupUi" $ e } )
   IF n == 0
      RETURN NIL
   ENDIF
   s     := AllTrim( aLines[ n ] )
   n     := At( "*", s )
   cMCls := AllTrim( SubStr( s, 1, n - 1 ) )
   cMNam := AllTrim( SubStr( s, n + 1 ) )
   hbqtui_stripFront( @cMCls, "(" )
   hbqtui_stripRear( @cMNam, ")" )

   AAdd( aWidgets, { cMCls, cMNam, cMCls + "()", cMCls + "()" } )

   /* Normalize */
   FOR EACH s IN aLines
      s := AllTrim( s )
      IF Right( s, 1 ) == ";"
         s := SubStr( s, 1, Len( s ) - 1 )
      ENDIF
      IF Left( s, 1 ) $ "/,*,{,}"
         s := ""
      ENDIF
   NEXT

   FOR EACH s IN aLines

      IF ! Empty( s )

         /* Replace Qt::* with actual values */
         hbqtui_replaceConstants( @s )

         IF "setupUi" $ s
            lCreateFinished := .T.

         ELSEIF Left( s, 1 ) == "Q" .AND. ! lCreateFinished .AND. ( n := At( "*", s ) ) > 0
            // We will deal later - just skip

         ELSEIF hbqtui_notAString( s ) .AND. ! Empty( aReg := hb_regex( regEx, s ) )
            cCls := RTrim( aReg[ 1 ] )
            s := AllTrim( StrTran( s, cCls, "",, 1 ) )
            IF ( n := At( "(", s ) ) > 0
               cNam := SubStr( s, 1, n - 1 )
               AAdd( aWidgets, { cCls, cNam, cCls + "()", cCls + SubStr( s, n ) } )
            ELSE
               cNam := s
               AAdd( aWidgets, { cCls, cNam, cCls + "()", cCls + "()" } )
            ENDIF

         ELSEIF hbqtui_isObjectNameSet( s )
            // Skip - we already know the object name and will set after construction

         ELSEIF ! Empty( cText := hbqtui_pullSetToolTip( aLines, s:__enumIndex() ) )
            n := At( "->", cText )
            cNam := AllTrim( SubStr( cText, 1, n - 1 ) )
            cCmd := hbqtui_formatCommand( SubStr( cText, n + 2 ), .T., aWidgets )
            AAdd( aCommands, { cNam, cCmd } )

         ELSEIF ! Empty( cText := hbqui_pullText( aLines, s:__enumIndex() ) )
            n := At( "->", cText )
            cNam := AllTrim( SubStr( cText, 1, n - 1 ) )
            cCmd := hbqtui_formatCommand( SubStr( cText, n + 2 ), .T., aWidgets )
            AAdd( aCommands, { cNam, cCmd } )

         ELSEIF hbqtui_isValidCmdLine( s ) .AND. !( "->" $ s ) .AND. ( ( n := At( ".", s ) ) > 0  )  /* Assignment to objects on stack */
            cNam := SubStr( s, 1, n - 1 )
            cCmd := SubStr( s, n + 1 )
            cCmd := hbqtui_formatCommand( cCmd, .F., aWidgets )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            AAdd( aCommands, { cNam, cCmd } )

         ELSEIF !( Left( s, 1 ) $ '#/*"' ) .AND. ;          /* Assignment with properties from objects */
                        ( n := At( ".", s ) ) > 0 .AND. ;
                        At( "->", s ) > n
            cNam := SubStr( s, 1, n - 1 )
            cCmd := SubStr( s, n + 1 )
            cCmd := hbqtui_formatCommand( cCmd, .F., aWidgets )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            AAdd( aCommands, { cNam, cCmd } )

         ELSEIF ( n := At( "->", s ) ) > 0                  /* Assignments or calls to objects on heap */
            cNam := SubStr( s, 1, n - 1 )
            cCmd := hbqtui_formatCommand( SubStr( s, n + 2 ), .F., aWidgets )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            AAdd( aCommands, { cNam, cCmd } )

         ELSEIF ( n := At( "= new", s ) ) > 0
            IF ( n1 := At( "*", s ) ) > 0 .AND. n1 < n
               s := AllTrim( SubStr( s, n1 + 1 ) )
            ENDIF
            n    := At( "= new", s )
            cNam := AllTrim( SubStr( s, 1, n - 1 ) )
            cCmd := AllTrim( SubStr( s, n + Len( "= new" ) ) )
            cCmd := hbqtui_setObjects( cCmd, aWidgets )
            n := At( "(", cCmd )
            cCls := SubStr( cCmd, 1, n - 1 )
            AAdd( aWidgets, { cCls, cNam, cCls + "()", cCls + SubStr( cCmd, n ) } )

         ENDIF
      ENDIF
   NEXT

   aLinesPRG := {}

   AAdd( aLinesPRG, "/* WARNING: Automatically generated source file. DO NOT EDIT! */" )
   AAdd( aLinesPRG, "" )
   AAdd( aLinesPRG, '#include "hbqtgui.ch"' )

   AAdd( aLinesPRG, "" )
   AAdd( aLinesPRG, "FUNCTION " + cFuncName + "( qParent )" )
   AAdd( aLinesPRG, "   LOCAL oRootWidget" )
   AAdd( aLinesPRG, "   LOCAL hWidget := { => }" )
   AAdd( aLinesPRG, "" )
   AAdd( aLinesPRG, "   hb_hCaseMatch( hWidget, .F. )" )
   AAdd( aLinesPRG, "   hb_hKeepOrder( hWidget, .T. )" )
   AAdd( aLinesPRG, "" )

   SWITCH cMCls
   CASE "QDialog"
      AAdd( aLinesPRG, "   oRootWidget := QDialog( qParent )" )
      EXIT
   CASE "QWidget"
      AAdd( aLinesPRG, "   oRootWidget := QWidget( qParent )" )
      EXIT
   CASE "QMainWindow"
      AAdd( aLinesPRG, "   oRootWidget := QMainWindow( qParent )" )
      EXIT
   ENDSWITCH
   AAdd( aLinesPRG, "  " )
   AAdd( aLinesPRG, "   oRootWidget:setObjectName( " + HBQTUI_STRINGIFY( cMNam ) + " )" )
   AAdd( aLinesPRG, "  " )
   AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cMNam ) ) + " ] := oRootWidget" )
   AAdd( aLinesPRG, "  " )

   FOR EACH item IN aWidgets
      IF item:__enumIndex() > 1
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( item[ 2 ] ) ) + " ] := " + StrTran( item[ 4 ], "o[", "hWidget[" ) )
      ENDIF
   NEXT
   AAdd( aLinesPRG, "" )

   FOR EACH item IN aCommands
      cNam := item[ 1 ]
      cCmd := item[ 2 ]
      cCmd := StrTran( cCmd, "true" , ".T." )
      cCmd := StrTran( cCmd, "false", ".F." )

      IF "addWidget" $ cCmd
         IF hbqtui_occurs( cCmd, "," ) >= 4
            cCmd := StrTran( cCmd, "addWidget", "addWidget" )
         ENDIF
      ELSEIF "addLayout" $ cCmd
         IF hbqtui_occurs( cCmd, "," ) >= 4
            cCmd := StrTran( cCmd, "addLayout", "addLayout" )
         ENDIF
      ENDIF

      IF "setToolTip(" $ cCmd
         s := hbqtui_pullToolTip( cCmd )
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setToolTip( [" + HBQTUI_STRIP_SQ( s ) + "] )" )

      ELSEIF "setPlainText(" $ cCmd
         s := hbqtui_pullToolTip( cCmd )
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setPlainText( [" + HBQTUI_STRIP_SQ( s ) + "] )" )

      ELSEIF "setStyleSheet(" $ cCmd
         s := hbqtui_pullToolTip( cCmd )
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setStyleSheet( [" + HBQTUI_STRIP_SQ( s ) + "] )" )

      ELSEIF "setText(" $ cCmd
         s := hbqtui_pullToolTip( cCmd )
         IF hbqtui_pullColumn( cCmd, @n )
            AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setText( " + hb_ntos( n ) + ", [" + HBQTUI_STRIP_SQ( s ) + "] )" )
         ELSE
            AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setText( [" + HBQTUI_STRIP_SQ( s ) + "] )" )
         ENDIF

      ELSEIF "setWhatsThis(" $ cCmd
         s := hbqtui_pullToolTip( cCmd )
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:setWhatsThis( [" + HBQTUI_STRIP_SQ( s ) + "] )" )

      ELSEIF "header()->" $ cCmd
         // TODO: how to handle : __qtreeviewitem->header()->setVisible( .F. )

      ELSEIF cCmd == "pPtr"
         // Nothing TO DO

      ELSE
         AAdd( aLinesPRG, "   hWidget[ " + HBQTUI_PAD_30( HBQTUI_STRINGIFY( cNam ) ) + " ]:" + StrTran( cCmd, "o[", "hWidget[" ) )

      ENDIF
   NEXT
   AAdd( aLinesPRG, "" )
   AAdd( aLinesPRG, "   RETURN HbQtUI():new( oRootWidget, hWidget )" )
   AAdd( aLinesPRG, "" )

   RETURN aLinesPRG

STATIC FUNCTION hbqtui_formatCommand( cCmd, lText, widgets )
   LOCAL regDefine
   LOCAL aDefine
   LOCAL n
   LOCAL n1
   LOCAL cNam
   LOCAL cCmd1

   STATIC s_nn := 100

   IF lText == NIL
      lText := .T.
   ENDIF

   cCmd := StrTran( cCmd, "QApplication_translate"   , "q__tr"        )
   cCmd := StrTran( cCmd, "QApplication::UnicodeUTF8", '"UTF8"'       )
   cCmd := StrTran( cCmd, "QString()"                , '""'           )
   cCmd := StrTran( cCmd, "QSize("                   , "QSize(" )
   cCmd := StrTran( cCmd, "QRect("                   , "QRect(" )

   IF "::" $ cCmd
      regDefine := hb_regexComp( "\b[A-Za-z_]+\:\:[A-Za-z_]+\b" )
      aDefine := hb_regex( regDefine, cCmd )
      IF ! Empty( aDefine )
         cCmd := StrTran( cCmd, "::", "_" )    /* Qt Defines  - how to handle */
      ENDIF
   ENDIF

   IF ! lText .AND. At( ".", cCmd ) > 0
      // sizePolicy     setHeightForWidth(ProjectProperties->sizePolicy().hasHeightForWidth());
      //
      IF ( At( "setHeightForWidth(", cCmd ) ) > 0
         cNam := "__qsizePolicy" + hb_ntos( ++s_nn )
         n    := At( "(", cCmd )
         n1   := At( ".", cCmd )
         cCmd1 := hbqtui_setObjects( SubStr( cCmd, n + 1, n1 - n - 1 ), widgets )
         cCmd1 := StrTran( cCmd1, "->", ":" )
         AAdd( widgets, { "QSizePolicy", cNam, "QSizePolicy()", "QSizePolicy(" + cCmd1 + ")" } )
         cCmd := 'setHeightForWidth(o[ "' + cNam + '" ]:' + SubStr( cCmd, n1 + 1 )
      ELSE
         cCmd := "pPtr"
      ENDIF
   ENDIF

   RETURN cCmd

STATIC FUNCTION hbqtui_isObjectNameSet( cString )
   RETURN "objectName" $ cString .OR. ;
          "ObjectName" $ cString

STATIC FUNCTION hbqtui_isValidCmdLine( cString )
   RETURN !( Left( cString, 1 ) $ '#/*"' )

STATIC FUNCTION hbqtui_notAString( cString )
   RETURN !( Left( cString, 1 ) == '"' )

STATIC FUNCTION hbqtui_occurs( cString, cCharToFind )
   LOCAL cChar
   LOCAL nCount

   nCount := 0
   FOR EACH cChar IN cString
      IF cChar == cCharToFind
         ++nCount
      ENDIF
   NEXT

   RETURN nCount

STATIC FUNCTION hbqtui_pullColumn( cCmd, nCol )

   IF     "(0," $ cCmd
      nCol := 0; RETURN .t.
   ELSEIF "(1," $ cCmd
      nCol := 1; RETURN .t.
   ELSEIF "(2," $ cCmd
      nCol := 2; RETURN .t.
   ENDIF

   RETURN .f.

STATIC FUNCTION hbqtui_pullToolTip( cCmd )
   LOCAL n
   LOCAL cString := ""

   IF ( n := At( ', "', cCmd ) ) > 0
      cString := AllTrim( SubStr( cCmd, n + 2 ) )
      IF ( n := At( '", 0', cString ) ) > 0
         cString := AllTrim( SubStr( cString, 1, n ) )
         cString := StrTran( cString, '\"', '"' )
         cString := StrTran( cString, '""' )
         cString := SubStr( cString, 2, Len( cString ) - 2 )
      ENDIF
   ENDIF

   RETURN cString

STATIC PROCEDURE hbqtui_replaceConstants( /* @ */ cString )
   LOCAL aResult
   LOCAL cConst
   LOCAL cCmdB
   LOCAL cCmdE
   LOCAL cOR
   LOCAL n

   LOCAL regDefine := hb_regexComp( "\b[A-Za-z_]+\:\:[A-Za-z_]+\b" )

   IF hbqtui_occurs( cString, "|" ) > 0

      aResult := hb_regexAll( regDefine, cString )

      IF ! Empty( aResult )
         cOR := "hb_bitOr( "
         FOR n := 1 TO Len( aResult )
            cOR += aResult[ n ][ 1 ]
            IF n < Len( aResult )
               cOR += ","
            ENDIF
         NEXT
         cOR += " )"
         cCmdB   := SubStr( cString, 1, At( aResult[ 1 ][ 1 ], cString ) - 1 )
         cConst  := aResult[ Len( aResult ) ][ 1 ]
         cCmdE   := SubStr( cString, At( cConst, cString ) + Len( cConst ) )
         cString := cCmdB + cOR + cCmdE
      ENDIF
   ENDIF

   IF "::" $ cString
      DO WHILE .T.
         aResult := hb_regex( regDefine, cString )
         IF Empty( aResult )
            EXIT
         ENDIF
         cString := StrTran( cString, aResult[ 1 ], StrTran( aResult[ 1 ], "::", "_" ) )
      ENDDO
   ENDIF

   RETURN

STATIC FUNCTION hbqtui_setObjects( cCmd, aWidgets )
   LOCAL n
   LOCAL cObj

   IF ( n := AScan( aWidgets, {| tmp | ( tmp[ 2 ] + "," ) $ cCmd } ) ) > 0
      cObj := aWidgets[ n ][ 2 ]
      cCmd := StrTran( cCmd, cObj + ",", 'o[ "' + cObj + '" ],' )
   ENDIF

   IF ( n := AScan( aWidgets, {| tmp | ( tmp[ 2 ] + ")" ) $ cCmd } ) ) > 0
      cObj := aWidgets[ n ][ 2 ]
      cCmd := StrTran( cCmd, cObj + ")", 'o[ "' + cObj + '" ])' )
   ENDIF

   IF ( n := AScan( aWidgets, {| tmp | ( tmp[ 2 ] + "->" ) $ cCmd } ) ) > 0
      cObj := aWidgets[ n ][ 2 ]
      cCmd := StrTran( cCmd, cObj + "->", 'o[ "' + cObj + '" ]:' )
   ENDIF

   RETURN cCmd

STATIC FUNCTION hbqui_pullText( aLines, nFrom )
   LOCAL cString := ""
   LOCAL nLen := Len( aLines )
   LOCAL aKeyword := { "setText(", "setPlainText(", "setStyleSheet(", "setWhatsThis(" }

   IF AScan( aKeyword, {| tmp | tmp $ aLines[ nFrom ] } ) > 0
      cString := aLines[ nFrom ]
      nFrom++
      DO WHILE nFrom <= nLen
         IF !( Left( aLines[ nFrom ], 1 ) == '"' )
            EXIT
         ENDIF
         cString += aLines[ nFrom ]
         aLines[ nFrom ] := ""
         nFrom++
      ENDDO
   ENDIF

   RETURN cString

STATIC FUNCTION hbqtui_pullSetToolTip( aLines, nFrom )
   LOCAL cString := ""
   LOCAL nLen := Len( aLines )

   IF "#ifndef QT_NO_TOOLTIP" $ aLines[ nFrom ]
      nFrom++
      DO WHILE nFrom <= nLen
         IF "#endif // QT_NO_TOOLTIP" $ aLines[ nFrom ]
            EXIT
         ENDIF
         cString += aLines[ nFrom ]
         aLines[ nFrom ] := ""
         nFrom++
      ENDDO
   ENDIF

   RETURN cString

STATIC FUNCTION hbqtui_stripFront( /* @ */ cString, cTkn )
   LOCAL n
   LOCAL nLen := Len( cTkn )

   IF ( n := At( cTkn, cString ) ) > 0
      cString := SubStr( cString, n + nLen )
      RETURN .T.
   ENDIF

   RETURN .F.

STATIC FUNCTION hbqtui_stripRear( /* @ */ cString, cTkn )
   LOCAL n

   IF ( n := RAt( cTkn, cString ) ) > 0
      cString := SubStr( cString, 1, n - 1 )
      RETURN .T.
   ENDIF

   RETURN .F.

/*======================================================================*/

STATIC FUNCTION qth_to_src( cQTHFileName, cCPPFileName, cDOCFileName, cQtModule, cQtVer )
   LOCAL oSrc

   oSrc := HbQtSource():new( cQtModule, cQtVer, cQTHFileName, cCPPFileName, cDOCFileName )
   oSrc:build()

   RETURN .T.

/*----------------------------------------------------------------------*/

CREATE CLASS HbQtSource

   DATA   cCPPFileName, cDOCFileName
   DATA   hRef

   DATA   cQtModule
   DATA   cQtVer
   DATA   cQtObject

   DATA   aMethods                                INIT {}

   DATA   isList                                  INIT .f.
   DATA   isDestructor                            INIT .t.
   DATA   isConstructor                           INIT .f.
   DATA   isObject                                INIT .t.
   DATA   isDetached                              INIT .f.
   DATA   areMethodsClubbed                       INIT .t.

   DATA   class_                                  INIT {}
   DATA   subCls_                                 INIT {}
   DATA   docum_                                  INIT {}
   DATA   code_                                   INIT {}
   DATA   cls_                                    INIT {}
   DATA   new_                                    INIT {}
   DATA   newW_                                   INIT {}
   DATA   old_                                    INIT {}
   DATA   enums_                                  INIT {}
   DATA   enum_                                   INIT {}
   DATA   protos_                                 INIT {}
   DATA   varbls_                                 INIT {}
   DATA   slots_                                  INIT {}

   DATA   dummy_                                  INIT {}
   DATA   func_                                   INIT { { "", 0 } }
   DATA   txt_                                    INIT {}
   DATA   cmntd_                                  INIT {}
   DATA   doc_                                    INIT {}
   DATA   constructors_                           INIT {}

   DATA   nFuncs                                  INIT 0
   DATA   nCnvrtd                                 INIT 0

   DATA   cFunc
   DATA   cTrMode

   DATA   cInt                                    INIT "int,qint16,quint16,short,ushort,unsigned"
   DATA   cIntLong                                INIT "qint32,quint32,QRgb"
   DATA   cIntLongLong                            INIT "qint64,quint64,qlonglong,qulonglong,ulong"

   METHOD new( cQtModule, cQtVer, cQTHFileName, cCPPFileName, cDOCFileName )
   METHOD parseProto( cProto, fBody_ )
   METHOD parseVariables( cProto )
   METHOD build()
   METHOD getConstructor( nClsType )
   METHOD getConstructorW()
   METHOD buildCppCode( oMtd )
   METHOD buildMethodBody( oMtd )
   METHOD buildDOC()
   METHOD getMethodBody( oMtd, cMtdName, aMethods, nClsType )
   METHOD normalizeCmd( oMtd, v )
   METHOD getReturnAsList( oMtd, FP, cPrefix )

ENDCLASS

/*----------------------------------------------------------------------*/

METHOD HbQtSource:new( cQtModule, cQtVer, cQTHFileName, cCPPFileName, cDOCFileName )
   LOCAL cQth, s, n, i, n1, b_, tmp, cOrg, fBody_
   LOCAL f

   ::hRef := { => }
   hb_HKeepOrder( ::hRef, .T. )

   IF empty( GetEnv( "HBQT_BUILD_TR_LEVEL" ) )
      ::cTrMode := "HB_TR_DEBUG"
   ELSE
      ::cTrMode := upper( GetEnv( "HBQT_BUILD_TR_LEVEL" ) )
      IF ! ( ::cTrMode $ "HB_TR_ALWAYS,HB_TR_WARNING,HB_TR_ERROR" )
         ::cTrMode := "HB_TR_DEBUG"
      ENDIF
   ENDIF

   hb_fNameSplit( cQTHFileName,, @tmp )

   ::cCPPFileName := cCPPFileName
   ::cDOCFileName := cDOCFileName

   ::cQtModule := cQtModule
   ::cQtVer    := cQtVer

   ::cQtObject := tmp

   cQth := hb_memoread( cQTHFileName )

   /* Prepare to be parsed properly */
   IF ! hb_eol() == Chr( 10 )
      cQth := StrTran( cQth, hb_eol(), Chr( 10 ) )
   ENDIF
   IF ! hb_eol() == Chr( 13 ) + Chr( 10 )
      cQth := StrTran( cQth, Chr( 13 ) + Chr( 10 ), Chr( 10 ) )
   ENDIF

   IF !empty( ::class_:= hbqtgen_PullOutSection( @cQth, "CLASS" ) )
      FOR EACH s IN ::class_
         IF ( n := at( "=", s ) ) > 0
            aadd( ::cls_, { alltrim( substr( s, 1, n - 1 ) ), alltrim( substr( s, n + 1 ) ) } )
         ENDIF
      NEXT
   ENDIF

   /* Pull out SUBCLASS section */
   ::subCls_ := hbqtgen_PullOutSection( @cQth, "SUBCLASS" )

   /* Pull out Doc Section */
   ::docum_  := hbqtgen_PullOutSection( @cQth, "DOC"   )

   /* Pull out Code Section */
   ::code_   := hbqtgen_PullOutSection( @cQth, "CODE"   )

   /* Separate constructor function */
   ::new_:= {}
   f := "HB_FUNC( QT_" + upper( ::cQtObject ) + " )"
   ::cFunc := "HB_FUNC_STATIC( NEW )"

   n := ascan( ::code_, {|e| f $ e } )

   aadd( ::new_, ::cFunc )
   FOR i := n + 1 TO len( ::code_ )
      aadd( ::new_, ::code_[ i ] )
      IF RTrim( ::code_[ i ] ) == "}"
         n1 := i
         EXIT
      ENDIF
   NEXT
   ::old_ :={}
   FOR i := 1 TO len( ::code_ )
      IF i < n .or. i > n1
         aadd( ::old_, ::code_[ i ] )
      ENDIF
   NEXT
   ::code_ := ::old_

   ::newW_:= aClone( ::new_ )
   ::newW_[ 1 ] := "HB_FUNC( " + upper( ::cQtObject ) + " )"

   /* Pullout constructor methods */
   #if 0
   tmp := ::cQtObject + " ("
   FOR EACH s IN ::code_
      IF ( n := at( tmp, s ) ) > 0 .AND. ! ( "~" $ s )
         aadd( ::constructors_, substr( s, n ) )
      ENDIF
   NEXT
   #endif

   /* Pull out Enumerators  */
   ::enums_:= hbqtgen_PullOutSection( @cQth, "ENUMS"  )
   ::enum_:= {}
   FOR EACH s IN ::enums_
      IF "enum " $ s .or. "flags " $ s
         b_:= hb_ATokens( alltrim( s ), " " )
         aadd( ::enum_, b_[ 2 ] )
      ENDIF
   NEXT

   /* Pull out Prototypes   */
//   ::protos_ := hbqtgen_PullOutSection( @cQth, "PROTOS" )
   tmp := hbqtgen_PullOutSection( @cQth, "PROTOS" )
   aeval( ::constructors_, {|e| aadd( ::protos_, e ) } )
   aeval( tmp, {|e| aadd( ::protos_, e ) } )

   /* Pull out Variables */
   ::varbls_ := hbqtgen_PullOutSection( @cQth, "VARIABLES" )

   /* Pull Out Signals      */
   ::slots_  := hbqtgen_PullOutSection( @cQth, "SLOTS"  )

   /* Combine signals and protos : same nature */
   aeval( ::slots_, {|e| aadd( ::protos_, e ) } )

   ::isList            := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "list"        .AND. lower( e_[ 2 ] ) == "yes" } ) > 0
   ::isDetached        := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "detached"    .AND. lower( e_[ 2 ] ) == "yes" } ) > 0
   ::isConstructor     := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "constructor" .AND. lower( e_[ 2 ] ) == "no"  } ) == 0
   ::isDestructor      := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "destructor"  .AND. lower( e_[ 2 ] ) == "no"  } ) == 0
   ::isObject          := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "qobject"     .AND. lower( e_[ 2 ] ) == "no"  } ) == 0
   ::areMethodsClubbed := ascan( ::cls_, {|e_| lower( e_[ 1 ] ) == "clubmethods" .AND. lower( e_[ 2 ] ) == "no"  } ) == 0
   /* Determine Constructor - but this is hacky a bit. What could be easiest ? */
   IF ! ::isConstructor
      FOR i := 3 TO len( ::new_ ) - 1
         IF !( left( ltrim( ::new_[ i ] ), 2 ) == "//" )
            IF "__HB_RETPTRGC__(" $ ::new_[ i ]
               ::isConstructor := .t.
               EXIT
            ENDIF
         ENDIF
      NEXT
   ENDIF

   FOR EACH s IN ::protos_
      cOrg := s
      IF empty( s := alltrim( s ) )
         LOOP
      ENDIF

      /* Check if proto is commented out */
      IF left( s,2 ) == "//"
         aadd( ::cmntd_, cOrg )
         LOOP
      ENDIF
      /* Check if it is not ANSI C Comment */
      IF left( alltrim( cOrg ),1 ) $ "/*"
         LOOP
      ENDIF
      /* Another comment tokens */
      IF empty( s ) .or. left( s,1 ) $ "#;}"
         LOOP
      ENDIF

      ::nFuncs++

      fBody_:= {}
      IF right( s, 1 ) == "{"
         fBody_:= hbqtgen_PullOutFuncBody( ::protos_, s:__enumIndex() )
         s := substr( s, 1, len( s ) - 1 )
      ENDIF
      IF ::parseProto( s, fBody_ )
         ::nCnvrtd++
      ELSE
         aadd( ::dummy_, cOrg )
      ENDIF
   NEXT

   FOR EACH s IN ::varbls_
      cOrg := s

      IF empty( s := alltrim( s ) )
         LOOP
      ENDIF
      /* Check if proto is commented out */
      IF left( s,2 ) == "//"
         aadd( ::cmntd_, cOrg )
         LOOP
      ENDIF
      /* Check if it is not ANSI C Comment */
      IF left( alltrim( cOrg ),1 ) $ "/*"
         LOOP
      ENDIF
      /* Another comment tokens */
      IF empty( s ) .or. left( s,1 ) $ "#;"
         LOOP
      ENDIF

      ::nFuncs++

      IF ::parseVariables( s )
         ::nCnvrtd++
      ELSE
         aadd( ::dummy_, cOrg )
      ENDIF
   NEXT

   RETURN Self

/*----------------------------------------------------------------------*/

METHOD HbQtSource:build()
   LOCAL i, s, oMtd, tmp, tmp1, n, k
   LOCAL aLine
   LOCAL uQtObject

   uQtObject := upper( ::cQtObject )

   ::hRef[ ::cQtObject ] := NIL

   /* Methods Body */
   FOR EACH oMtd IN ::aMethods
      ::buildMethodBody( oMtd, ::aMethods )
   NEXT

   /* Pull .cpp copyright text */
   aLine := hbqtgen_BuildCopyrightText( 0, ::cQtVer )

   /* Place ENUM definitions into the source */
   IF !empty( ::enums_ )
      aadd( aLine, "/*" )
      aeval( ::enums_, {|e| iif( !empty( e ), aadd( aLine, " *  " + e ), NIL ) } )
      aadd( aLine, " */ " )
      aadd( aLine, "" )
   ENDIF

   /* Insert information about prototypes not converted to functions */
#if 0
   aadd( aLine, "/*" )
   aadd( aLine, " *  Constructed[ " + hb_ntos( ::nCnvrtd ) + "/" + hb_ntos( ::nFuncs ) + " [ " + hb_ntos( ::nCnvrtd / ::nFuncs * 100 ) + "% ] ]" )
   aadd( aLine, " *  " )
   IF !empty( ::dummy_ )
      aadd( aLine, " *  *** Unconvered Prototypes ***" )
      aadd( aLine, " *  " )
      aeval( ::dummy_, {|e| aadd( aLine, " *  " + e ) } )
   ENDIF
   IF !empty( ::cmntd_ )
      aadd( aLine, " *  " )
      aadd( aLine, " *  " + "*** Commented out prototypes ***" )
      aadd( aLine, " *  " )
      aeval( ::cmntd_, {|e| aadd( aLine, " *  " + e ) } )
   ENDIF
   aadd( aLine, " */ " )
   aadd( aLine, "" )
#endif

   IF ::isConstructor
      FOR i := 3 TO len( ::new_ ) - 1
         IF !( left( ltrim( ::new_[ i ] ), 2 ) == "//" )
            IF "__HB_RETPTRGC__(" $ ::new_[ i ]
               tmp1 := ::new_[ i ]
               DO WHILE ( tmp := At( "hbqt_par_", tmp1 ) ) > 0
                  tmp1 := SubStr( tmp1, tmp + Len( "hbqt_par_" ) )
                  hbqtgen_AddRef( ::hRef, Left( tmp1, At( "(", tmp1 ) - 1 ) )
                  tmp1 := SubStr( tmp1, At( "(", tmp1 ) + 1 )
               ENDDO
            ENDIF
         ENDIF
      NEXT
   ENDIF

   /*----------------------------------------------------------------------*/
   /* Generate necessary declarations */

   aadd( aLine, "HB_EXTERN_BEGIN" )
   aadd( aLine, "" )
   aadd( aLine, "HB_FUNC_EXTERN( __HB" + Upper( ::cQtModule ) + " );" )
   FOR EACH s IN ::hRef
      aadd( aLine, "HB_FUNC_EXTERN( HB_" + upper( s:__enumKey() ) + " );" )
   NEXT
   aadd( aLine, "" )
   aadd( aLine, "void _hb_force_link_" + ::cQtObject +"( void )" )
   aadd( aLine, "{" )
   aadd( aLine, "   HB_FUNC_EXEC( __HB" + Upper( ::cQtModule ) + " );" )
   FOR EACH s IN ::hRef
      aadd( aLine, "   HB_FUNC_EXEC( HB_" + upper( s:__enumKey() ) + " );" )
   NEXT
   aadd( aLine, "}" )
   aadd( aLine, "" )
   FOR EACH s IN ::hRef
      aadd( aLine, "extern HB_EXPORT HBQT_GC_FUNC( hbqt_gcRelease_" + s:__enumKey() + " );" )
   NEXT
   aadd( aLine, "" )
   FOR EACH s IN ::hRef
      aadd( aLine, "extern HB_EXPORT void * hbqt_gcAllocate_" + s:__enumKey() + "( void * pObj, bool bNew );" )
   NEXT
   aadd( aLine, "" )

   n := ascan( ::cls_, {|e_| left( lower( e_[ 1 ] ), 7 ) == "inherit" .and. !empty( e_[ 2 ] ) } )
   IF n > 0
      s := upper( strtran( ::cls_[ n, 2 ], "Q", "HB_Q" ) )
   ELSE
      s := "HBQTOBJECTHANDLER"
   ENDIF
   FOR EACH k IN hb_aTokens( s, "," )
      aadd( aLine, "HB_FUNC_EXTERN( " + upper( alltrim( k ) ) + " );" )
   NEXT
   aadd( aLine, "" )
   aadd( aLine, "HB_EXTERN_END" )
   aadd( aLine, "" )
   aadd( aLine, "static void s_registerMethods( HB_USHORT uiClass );" )
   aadd( aLine, "" )

   FOR EACH s IN ::hRef
      IF s:__enumKey() == "QList" /* TOFIX: Ugly hack */
         tmp := s:__enumKey() + "< void * >"
      ELSE
         tmp := s:__enumKey()
      ENDIF
      aadd( aLine, PadR( "#define hbqt_par_" + s:__enumKey() + "( n )", 64 ) + PadR( "( ( " + tmp, 48 ) + "* ) hbqt_gcpointer( n ) )" )
   NEXT
   aadd( aLine, "" )
   FOR EACH s IN ::hRef
      aadd( aLine, PadR( "#define HBQT_TYPE_" + s:__enumKey(), 64 ) + "( ( HB_U32 ) 0x" + hb_NumToHex( hb_crc32( "HBQT_TYPE_" + s:__enumKey() ), 8 ) + " )" )
   NEXT
   aadd( aLine, "" )
   /*----------------------------------------------------------------------*/

   /* Insert user defined code - INCLUDEs */
   aadd( aLine, "#include <QtCore/QPointer>" )
   n := aScan( ::code_, {|e| "gcMark" $ e } )
   IF !empty( ::code_ )
      IF n == 0
         aeval( ::code_, {| e | aadd( aLine, StrTran( e, chr( 13 ) ) ) } )
      ELSE
         aeval( ::code_, {| e | aadd( aLine, StrTran( e, chr( 13 ) ) ) }, 1, n-1 )
      ENDIF
      aadd( aLine, "" )
   ENDIF

   aadd( aLine, "typedef struct"                  )
   aadd( aLine, "{"                               )
   IF ::isObject
      aadd( aLine, "   QPointer< "+ ::cQtObject +" > ph;" )
   ELSE
      IF ::isList
          aadd( aLine, "   " + ::cQtObject + "< void * > * ph;"                    )
      ELSE
          aadd( aLine, "   " + ::cQtObject + " * ph;"                    )
      ENDIF
   ENDIF
   aadd( aLine, "   bool bNew;"                     )
   aadd( aLine, "   PHBQT_GC_FUNC func;"            )
   aadd( aLine, "   HB_U32 type;"                   )
   aadd( aLine, "   PHBQT_GC_FUNC mark;"            )
   aadd( aLine, "} HBQT_GC_T_" + ::cQtObject + ";"  )
   aadd( aLine, " "                                 )
   aadd( aLine, " "                                 )
   IF n > 0
      aeval( ::code_, {| e | aadd( aLine, StrTran( e, chr( 13 ) ) ) }, n )
   ENDIF
   aadd( aLine, " "                                 )
   aadd( aLine, " "                                 )

   aadd( aLine, "HBQT_GC_FUNC( hbqt_gcRelease_" + ::cQtObject + " )"  )
   aadd( aLine, "{"                                     )
   IF ::isDestructor .AND. ::isConstructor
      IF ::isObject
         aadd( aLine, "   HBQT_GC_T_" + ::cQtObject + " * p = ( HBQT_GC_T_" + ::cQtObject + " * ) Cargo; " )
         aadd( aLine, "   " )
         aadd( aLine, "   if( p )" )
         aadd( aLine, "   {" )
         aadd( aLine, "      if( p->bNew )" )
         aadd( aLine, "      {" )
         aadd( aLine, "         if( p->ph )" )
         aadd( aLine, "         {" )
         #ifdef _GEN_TRACE_
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p %p YES_rel_' + ::cQtObject + '   /.\\   ", ( void * ) p, ( void * ) p->ph ) );' )
         #endif
         aadd( aLine, "            delete ( " + ::cQtObject + " * )( p->ph ); " )
         #ifdef _GEN_TRACE_
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p %p YES_rel_' + ::cQtObject + '   \\./   ", ( void * ) p, ( void * ) p->ph ) );' )
         #endif
         aadd( aLine, "         }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "         else" )
         aadd( aLine, "         {" )
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p DEL_rel_' + ::cQtObject + '    :     already deleted!", ( void * ) p->ph ) );' )
         aadd( aLine, "         }" )
         #endif
         aadd( aLine, "      }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "      else" )
         aadd( aLine, "      {" )
         aadd( aLine, '         HB_TRACE( ' + ::cTrMode + ', ( "ph=%p PTR_rel_' + ::cQtObject + '    :    not a _new_ object", ( void * ) p->ph ) );' )
         aadd( aLine, "      }" )
         #endif
         aadd( aLine, "      p->ph = NULL;" )
         aadd( aLine, "   }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "   else" )
         aadd( aLine, "   {" )
         aadd( aLine, '      HB_TRACE( ' + ::cTrMode + ', ( "DEL_rel_' + ::cQtObject + '    :     not valid GC object" ) );' )
         aadd( aLine, "   }" )
         #endif
      ELSE
         aadd( aLine, "   HBQT_GC_T_" + ::cQtObject + " * p = ( HBQT_GC_T_" + ::cQtObject + " * ) Cargo; " )
         aadd( aLine, "   " )
         aadd( aLine, "   if( p )" )
         aadd( aLine, "   {" )
         aadd( aLine, "      if( p->bNew )" )
         aadd( aLine, "      {" )
         aadd( aLine, "         if( p->ph )" )
         aadd( aLine, "         {" )
         #ifdef _GEN_TRACE_
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p    _rel_' + ::cQtObject + '   /.\\", ( void * ) p->ph ) );' )
         #endif
         IF ::isList
         aadd( aLine, "            int i; " )
         aadd( aLine, "            for( i = 0; i < p->ph->size(); i++ )" )
         aadd( aLine, "            {" )
         aadd( aLine, "               hb_itemRelease( p->ph->at( i ) );" )
         aadd( aLine, "            }" )
         ENDIF
         aadd( aLine, "            delete ( ( " + ::cQtObject + iif( ::isList, "< void * >", "" ) + " * ) p->ph ); " )
         #ifdef _GEN_TRACE_
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p YES_rel_' + ::cQtObject + '   \\./", ( void * ) p->ph ) );' )
         #endif
         aadd( aLine, "         }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "         else" )
         aadd( aLine, "         {" )
         aadd( aLine, '            HB_TRACE( ' + ::cTrMode + ', ( "ph=%p DEL_rel_' + ::cQtObject + '    :     object already deleted!", ( void * ) p->ph ) );' )
         aadd( aLine, "         }" )
         #endif
         aadd( aLine, "      }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "      else" )
         aadd( aLine, "      {" )
         aadd( aLine, '         HB_TRACE( ' + ::cTrMode + ', ( "ph=%p DEL_rel_' + ::cQtObject + '    :     not a _new_ object!", ( void * ) p->ph ) );' )
         aadd( aLine, "      }" )
         #endif
         aadd( aLine, "      p->ph = NULL;" )
         aadd( aLine, "   }" )
         #ifdef _GEN_TRACE_
         aadd( aLine, "   else" )
         aadd( aLine, "   {" )
         aadd( aLine, '      HB_TRACE( ' + ::cTrMode + ', ( "ph=%p PTR_rel_' + ::cQtObject + '    :    not a valid GC object!", ( void * ) p ) );' )
         aadd( aLine, "   }" )
         #endif
      ENDIF
   ELSE
      aadd( aLine, "   /* CASE else */" )
      aadd( aLine, "   HBQT_GC_T * p = ( HBQT_GC_T * ) Cargo;" )
      aadd( aLine, "   " )
      aadd( aLine, "   if( p && p->bNew )" )
      aadd( aLine, "      p->ph = NULL;" )
   ENDIF
   aadd( aLine, "}" )
   aadd( aLine, "" )

   aadd( aLine, "void * hbqt_gcAllocate_" + ::cQtObject + "( void * pObj, bool bNew )" )
   aadd( aLine, "{                                      " )
   IF ::isObject
      aadd( aLine, "   HBQT_GC_T_" + ::cQtObject + " * p = ( HBQT_GC_T_" + ::cQtObject + " * ) hb_gcAllocate( sizeof( HBQT_GC_T_" + ::cQtObject + " ), hbqt_gcFuncs() );" )
   ELSE
      aadd( aLine, "   HBQT_GC_T_" + ::cQtObject + " * p = ( HBQT_GC_T_" + ::cQtObject + " * ) hb_gcAllocate( sizeof( HBQT_GC_T_" + ::cQtObject + " ), hbqt_gcFuncs() );" )
   ENDIF
   aadd( aLine, "" )
   IF ::isObject
      aadd( aLine, "   new( & p->ph ) QPointer< "+ ::cQtObject +" >( ( " + ::cQtObject + " * ) pObj );" )
   ELSE
      aadd( aLine, "   p->ph = ( " + ::cQtObject + iif( ::isList, "< void * >", "" ) + " * ) pObj;" )
   ENDIF
   aadd( aLine, "   p->bNew = bNew;" )
   aadd( aLine, "   p->func = hbqt_gcRelease_" + ::cQtObject + ";" )
   aadd( aLine, "   p->type = HBQT_TYPE_" + ::cQtObject + ";" )
   if n > 0
      aadd( aLine, "   p->mark = hbqt_gcMark_" + ::cQtObject + ";" )
   else
      aadd( aLine, "   p->mark = NULL;" )
   endif
   aadd( aLine, "" )
   #ifdef _GEN_TRACE_
   aadd( aLine, "   if( bNew )" )
   aadd( aLine, "   {" )
   aadd( aLine, '      HB_TRACE( ' + ::cTrMode + ', ( "ph=%p    _new_' + ::cQtObject + iif( ::isObject, '  under p->pq', '' ) + '", ( void * ) pObj ) );' )
   aadd( aLine, "   }" )
   aadd( aLine, "   else" )
   aadd( aLine, "   {" )
   aadd( aLine, '      HB_TRACE( ' + ::cTrMode + ', ( "ph=%p NOT_new_' + ::cQtObject + '", ( void * ) pObj ) );' )
   aadd( aLine, "   }" )
   #endif
   aadd( aLine, "   return p;" )
   aadd( aLine, "}" )
   aadd( aLine, "" )

   /* Internal class instantiation. TODO: Rename to __QCLASS */
   aadd( aLine, "HB_FUNC( HB_" + uQtObject + " )" )
   aadd( aLine, "{" )
   aadd( aLine, "   static PHB_ITEM s_oClass = NULL;" )
   aadd( aLine, '   HB_TRACE( HB_TR_DEBUG, ( "HB_' + uQtObject +'" ) );' )
   aadd( aLine, "   if( s_oClass == NULL )" )
   aadd( aLine, "   {" )
   aadd( aLine, "      s_oClass = hb_itemNew( NULL );" )
   aadd( aLine, "      hbqt_addDeleteList( s_oClass );" )
   FOR EACH k IN hb_aTokens( s, "," )
      aadd( aLine, "      HB_FUNC_EXEC( " + Upper( AllTrim( k ) ) + " );" )
   NEXT
   aadd( aLine, '      PHB_ITEM oClass = hbqt_defineClassBegin( "' + uQtObject + '", s_oClass, "' + s + '" );' )
   aadd( aLine, "      if( oClass )" )
   aadd( aLine, "      {" )
   aadd( aLine, "         s_registerMethods( hb_objGetClass( hb_stackReturnItem() ) );" )
   aadd( aLine, "         hbqt_defineClassEnd( s_oClass, oClass );" )
   aadd( aLine, "      }" )
   aadd( aLine, "      return;" )
   aadd( aLine, "   }" )
   aadd( aLine, '   hb_objSendMsg( s_oClass, "INSTANCE", 0 );' )
   aadd( aLine, "}" )
   aadd( aLine, "" )

   /* Build PRG level constructor */
   aadd( aLine, ::newW_[ 1 ] )           // Func definition
   aadd( aLine, ::newW_[ 2 ] )           // {
   aeval( ::getConstructorW(), {|e| aadd( aLine, e ) } )

   /* Build the constructor */
   aadd( aLine, ::new_[ 1 ] )           // Func definition
   aadd( aLine, ::new_[ 2 ] )           // {
   aeval( ::getConstructor( 0 ), {|e| aadd( aLine, e ) } )

   /* Insert Functions */
   aeval( ::txt_, {|e| aadd( aLine, strtran( e, chr( 13 ) ) ) } )

   aadd( aLine, "" )
   aadd( aLine, "static void s_registerMethods( HB_USHORT uiClass )" )
   aadd( aLine, "{" )
   aadd( aLine, '   hb_clsAdd( uiClass, ' +padr( '"new"',35) +', HB_FUNCNAME( ' + padr( upper( "NEW" ),35) + ' ) );' )
   FOR EACH oMtd IN ::aMethods
      IF !empty( oMtd:cHBFunc )
         aadd( aLine, '   hb_clsAdd( uiClass, ' +padr( '"' + oMtd:cHBFunc +'"',35) +', HB_FUNCNAME( ' + padr( upper( oMtd:cHBFunc ),35) + ' ) );' )
   ENDIF
   NEXT
   aadd( aLine, "}" )
   aadd( aLine, "" )
   aadd( aLine, "HB_INIT_SYMBOLS_BEGIN( __HBQT_CLS_" + uQtObject  + "__ )" )
   aadd( aLine, '   { "' + uQtObject + '", { HB_FS_PUBLIC | HB_FS_LOCAL }, { HB_FUNCNAME( ' + uQtObject + ' ) }, NULL },' )
   aadd( aLine, '   { "HB_' + uQtObject + '", { HB_FS_PUBLIC | HB_FS_LOCAL }, { HB_FUNCNAME( HB_' + uQtObject + ' ) }, NULL }' )
   aadd( aLine, "HB_INIT_SYMBOLS_END( __HBQT_CLS_" + uQtObject + "__ )" )
   aadd( aLine, "" )

   /* Footer */
   hbqtgen_BuildFooter( @aLine, ::cQtVer )

   /* Build Document File */
   ::buildDOC()

   /* Distribute in specific lib subfolder */
   hbqtgen_CreateTarget( ::cCPPFileName, aLine )

   RETURN Self

/*----------------------------------------------------------------------*/

METHOD HbQtSource:getConstructor( nClsType )
   LOCAL i, s, aLine := {}

   HB_SYMBOL_UNUSED( nClsType )

   IF ::isConstructor
      IF ::isList
          aadd( aLine, "   " + ::cQtObject + "< void * > * pObj = NULL;" )
      ELSE
          aadd( aLine, "   " + ::cQtObject + " * pObj = NULL;" )
      ENDIF
      aadd( aLine, " " )
      FOR i := 3 TO len( ::new_ ) - 1
         IF !( left( ltrim( ::new_[ i ] ), 2 ) == "//" )
            IF "__HB_RETPTRGC__(" $ ::new_[ i ]
               s := ::new_[ i ]
               s := RTrim( strtran( s, "__HB_RETPTRGC__(", "pObj =" ) )
               IF ");" $ s
                  s := RTrim( strtran( s, ");" ) ) + ";"
               ENDIF
               s := strtran( s, "( " + ::cQtObject + "* )" )
               aadd( aLine, s )
            ELSE
               aadd( aLine, ::new_[ i ] )
            ENDIF
         ENDIF
      NEXT
      aadd( aLine, " " )
      aadd( aLine, "   hbqt_itemPushReturn( hbqt_gcAllocate_" + ::cQtObject + "( ( void * ) pObj, " + iif( ::isDetached, "false", "true" ) + " ), hb_stackSelfItem() );" )
   ELSE
      FOR i := 3 TO len( ::new_ ) - 1
          aadd( aLine, ::new_[ i ] )
      NEXT
   ENDIF
   aadd( aLine, ::new_[ len( ::new_ ) ] ) // }
   aadd( aLine, "" )

   RETURN aLine

/*----------------------------------------------------------------------*/

METHOD HbQtSource:getConstructorW()
   LOCAL aLine := ::getConstructor( 0 )

   aeval( aLine, {|e,i| aLine[ i ] := strtran( e, "hbqt_itemPushReturn", "hbqt_create_objectGC" ) } )
   aeval( aLine, {|e,i| aLine[ i ] := strtran( e, "hb_stackSelfItem()" , '"HB_' + upper( ::cQtObject ) + '"' ) } )

   RETURN aLine

/*----------------------------------------------------------------------*/

METHOD HbQtSource:normalizeCmd( oMtd, v )
   LOCAL FP

   IF ! oMtd:isConstructor
      FP := strtran( oMtd:cCmd, "hbqt_par_" + ::cQtObject + "( 1 )", v, 1, 1 )
   ELSE
      FP := oMtd:cCmd
   ENDIF

   /* Manage Re-Attached */
   IF oMtd:nAttach > 0
      FP := strtran( FP, ", false", ", true" )
   ENDIF

   RETURN FP

/*----------------------------------------------------------------------*/

METHOD HbQtSource:getReturnAsList( oMtd, FP, cPrefix )
   LOCAL cRetCast, n, n1, cCast, cParas, nStrCnt, lFar
   LOCAL aLines := {}

   IF oMtd:isRetList
      cRetCast := oMtd:oRet:cCast
      lFar := "*" $ cRetCast
      IF ( n := at( "<", cRetCast ) ) > 0
         IF ( n1 := at( ">", cRetCast ) ) > 0
            cCast := alltrim( substr( cRetCast, n + 1, n1 - n - 1 ) )
            cCast := strtran( cCast, "*" )
            cCast := strtran( cCast, " " )
         ENDIF
      ENDIF
      IF ! empty( cCast )
         cParas := oMtd:cParas
         nStrCnt := 0
         DO WHILE "%%%" $ cParas
            ++nStrCnt
            cParas := StrTran( cParas, "%%%", StrZero( nStrCnt, 2, 0 ), 1, 1 )
         ENDDO

         aadd( aLines, cPrefix + 'QList<PHB_ITEM> * qList = new QList< PHB_ITEM >;' )
         aadd( aLines, cPrefix + cRetCast + ' qL = p->' + oMtd:cFun + cParas + ';' )
         aadd( aLines, cPrefix + "int i;" )
         aadd( aLines, cPrefix + "for( i = 0; i < qL.size(); i++ )" )
         aadd( aLines, cPrefix + "{" )
         IF cCast == "QString"
            aadd( aLines, cPrefix + '   const char * str = qL.at( i ).data();' )
            aadd( aLines, cPrefix + '   PHB_ITEM pItem = hb_itemNew( NULL );' )
            aadd( aLines, cPrefix + '   hb_itemPutCL( pItem, str, strlen( str ) );' )
            aadd( aLines, cPrefix + '   qList->append( pItem );' )
         ELSEIF cCast == "int"
            aadd( aLines, cPrefix + '   // TOFIX: how TO release pItem ? ' )
            aadd( aLines, cPrefix + '   PHB_ITEM pItem = hb_itemNew( NULL );' )
            aadd( aLines, cPrefix + '   hb_itemPutNI( pItem, qL.at( i ) );' )
            aadd( aLines, cPrefix + '   qList->append( pItem );' )
         ELSEIF cCast == "qreal"
            aadd( aLines, cPrefix + '   // TOFIX: how TO release pItem ? ' )
            aadd( aLines, cPrefix + '   PHB_ITEM pItem = hb_itemNew( NULL );' )
            aadd( aLines, cPrefix + '   hb_itemPutND( pItem, qL.at( i ) );' )
            aadd( aLines, cPrefix + '   qList->append( pItem );' )
         ELSE
            IF lFar
               aadd( aLines, cPrefix + '   qList->append( hb_itemNew( hbqt_create_objectGC( hbqt_gcAllocate_' + cCast + '( ( void * ) qL.at( i ), false ) , "HB_' + upper( cCast ) + '" ) ) );' )
            ELSE
               aadd( aLines, cPrefix + '   qList->append( hb_itemNew( hbqt_create_objectGC( hbqt_gcAllocate_' + cCast + '( new ' + cCast + '( qL.at( i ) ), true ) , "HB_' + upper( cCast ) + '" ) ) );' )
            ENDIF
         ENDIF
         aadd( aLines, cPrefix + '}' )
         aadd( aLines, cPrefix + 'hbqt_create_objectGC( hbqt_gcAllocate_QList( qList, true ), "HB_QLIST" );' )
      ENDIF
   ELSE
      aadd( aLines, cPrefix + FP + ";" )
   ENDIF

   RETURN aLines

/*----------------------------------------------------------------------*/

METHOD HbQtSource:getMethodBody( oMtd, cMtdName, aMethods, nClsType )
   LOCAL FP, cTmp, n, v, t_, q, nStrCnt, ooMtd, i, a_
   LOCAL txt_:= {}

   HB_SYMBOL_UNUSED( cMtdName )

   // list all the overloaded methods
   a_ := {}
   FOR EACH ooMtd IN aMethods
      IF ooMtd:cFun == oMtd:cFun
        aadd( a_, ooMtd )
      ENDIF
   NEXT

   oMtd:cCmd := StrTran( oMtd:cCmd, "(  )", "()" )

   // check for methods already worked
   IF ( ascan( ::func_, {|e_| e_[ 1 ] == oMtd:cFun } ) ) > 0
      return {}
   ENDIF

   oMtd:cHBFunc := oMtd:cFun
   aadd( ::func_, { oMtd:cFun, 0, "" } )

//   aadd( txt_, "/* " + strtran( oMtd:cProto, chr( 13 ) ) + " */" )
   FOR EACH ooMtd IN a_
      aadd( txt_, "/* " + strtran( ooMtd:cProto, chr( 13 ) ) + " */" )
   NEXT

   v := "p"  /* NEVER change this */

   aadd( txt_, "HB_FUNC_STATIC( " + upper( oMtd:cHBFunc ) + " )" )
   aadd( txt_, "{" )
   #ifdef _GEN_TRACE_
// aadd( txt_, '   HB_TRACE( ' + ::cTrMode + ', ( "' + ::cQtObject + ":" + oMtd:cHBFunc + '" ) );' )
   aadd( txt_, '   HB_TRACE( HB_TR_DEBUG, ( "' + ::cQtObject + ":" + oMtd:cHBFunc + '" ) );' )
   #endif

   IF !empty( oMtd:fBody_ )
      aeval( oMtd:fBody_, {|e| aadd( txt_, e ) } )
   ELSE
      IF ! oMtd:isConstructor
         cTmp := ::cQtObject + iif( ::isList, "< void * >", "" )
         IF nClsType == 0
            aadd( txt_, "   " + cTmp + " * " + v + " = ( " + cTmp + " * ) hbqt_pPtrFromObj( 0 );" )
         ELSEIF nClsType == 1
            aadd( txt_, "   " + cTmp + " * " + v + " = ( " + cTmp + " * ) hbqt_getqtptr();" )
         ENDIF
      ENDIF

      IF len( a_ ) == 1 .AND. a_[ 1 ]:nArgs == 0
         IF ! oMtd:isConstructor
            FP := ::normalizeCmd( a_[ 1 ], v )

            aadd( txt_, "   if( " + v + " )" )
            aadd( txt_, "   {" )
            aeval( ::getReturnAsList( a_[ 1 ], FP, "      " ), {|e| aadd( txt_, e ) } )
            IF oMtd:oRet:cCast == "void"
               aadd( txt_, "      hb_itemReturn( hb_stackSelfItem() );" )
            ENDIF
            aadd( txt_, "   }" )
         ENDIF
      ELSE
         IF ! oMtd:isConstructor
            aadd( txt_, "   if( " + v + " )" )
            aadd( txt_, "   {" )
            aadd( txt_, "      int pcount = hb_pcount();" )
            aadd( txt_, "   " )
         ENDIF

         FOR i := 1 TO len( a_ )
            FP := ::normalizeCmd( a_[ i ], v )

            DO CASE
            CASE a_[ i ]:nArgs == 0
               aadd( txt_, "      " + iif( i > 1 , "else if", "if" ) + "( pcount == 0 )" )
               aadd( txt_, "      {" )
               aeval( ::getReturnAsList( a_[ i ], FP, "      " ), {|e| aadd( txt_, e ) } )
#if 0
               IF oMtd:oRet:cCast == "void"
                  aadd( txt_, "      hb_itemReturn( hb_stackSelfItem() );" )
               ENDIF
#endif
               aadd( txt_, "      }" )

            OTHERWISE
               t_ := __TY_TYPEScpp( a_[ i ], a_[ i ]:nArgsReal ) // return string of checks for real arguments

               IF ! empty( t_ )
                  t_ := " && " + t_
               ENDIF

               FOR n := a_[ i ]:nArgsReal + 1 TO a_[ i ]:nArgs
                  t_ += " && ( pcount < " + hb_ntos( n )+ " || " + hbide_paramCheckStrCpp( a_[i]:hArgs[ n ]:cTypeHB, n, a_[i]:hArgs[ n ]:cCast ) + ")"
               NEXT

               aadd( txt_, "      " + iif( i > 1 , "else if", "if" ) + "( pcount " + ;
                                      iif( a_[i]:nArgsReal == a_[i]:nArgs , "==", "<=" ) + " " + ;
                                      hb_ntos( a_[i]:nArgs ) + t_ + " )" )

               aadd( txt_, "      {" )

               IF ! empty( a_[ i ]:aPre )
                  FOR n := 1 TO len( a_[i]:aPre )
                     aadd( txt_, "         " + a_[i]:aPre[ n ][ 1 ] )
                  NEXT
                  aadd( txt_, "" )
               ENDIF

               /* Manage detached Argument */
               IF a_[ i ]:nDetach > 0
                  aadd( txt_, "        hbqt_detachgcpointer( " + hb_ntos( a_[i]:nDetach ) + " );" )
               ENDIF

               nStrCnt := 0
               DO WHILE "%%%" $ FP
                  ++nStrCnt
                  FP := StrTran( FP, "%%%", StrZero( nStrCnt, 2, 0 ), 1, 1 )
                  aadd( txt_, "         void * pText" + StrZero( nStrCnt, 2, 0 ) + " = NULL;" )
               ENDDO

               aeval( ::getReturnAsList( a_[ i ], FP, iif( ! a_[ i ]:isConstructor, "         ", "      " ) ), {|e| aadd( txt_, e ) } )

               FOR q := nStrCnt TO 1 STEP -1
                  aadd( txt_, "         hb_strfree( pText" + StrZero( q, 2, 0 ) + " );" )
               NEXT

               /* Return values back to PRG */
               IF ! empty( a_[ i ]:aPre )
                  aadd( txt_, "" )
                  FOR q := 1 TO len( a_[ i ]:aPre )
                     aadd( txt_, "         " + a_[i]:aPre[ q ][ 4 ] + "( " + a_[i]:aPre[ q ][ 3 ] + ", " + hb_ntos( a_[i]:aPre[ q ][ 2 ] ) + " );" )
                  NEXT
               ENDIF

               aadd( txt_, "      }" )
            ENDCASE
         NEXT

         aadd( txt_, "      else " )
         aadd( txt_, "      {" )
         aadd( txt_, "         hb_errRT_BASE( EG_ARG, 9999, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS ); " )
         aadd( txt_, "      }" )
         IF oMtd:oRet:cCast == "void"
            aadd( txt_, "  " )
            aadd( txt_, "      hb_itemReturn( hb_stackSelfItem() );" )
         ENDIF
         aadd( txt_, "   }" )

      ENDIF
   ENDIF

   aadd( txt_, "}" )
   aadd( txt_, ""  )

   RETURN txt_

/*----------------------------------------------------------------------*/

METHOD HbQtSource:buildMethodBody( oMtd )
   LOCAL aBdy
   LOCAL cFunc

   oMtd:cCmd := StrTran( oMtd:cCmd, "(  )", "()" )
   oMtd:cCmdN := StrTran( oMtd:cCmdN, "(  )", "()" )

   aBdy := ::getMethodBody( oMtd, "QT_" + upper( ::cQtObject ) + "_" + upper( oMtd:cHBFunc ), ::aMethods, 0 )

   aeval( aBdy, {|e| aadd( ::txt_, e ) } )

   cFunc := iif( ::areMethodsClubbed, hbqtgen_stripLastFrom( oMtd:cHBFunc, "_" ), oMtd:cHBFunc )

   oMtd:cDoc := "Qt_" + ::cQtObject + "_" + cFunc + "( p" + ::cQtObject + ;
                     iif( empty( oMtd:cDocs ), "", ", " + oMtd:cDocs ) + " ) -> " + oMtd:cPrgRet

   aadd( ::doc_, oMtd:cDoc )
   aadd( ::doc_, "" )

   RETURN Self

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_prgRetNormalize( cPrgRet )

   cPrgRet := strtran( cPrgRet, "::", "_" )
   cPrgRet := strtran( cPrgRet, "<", "_" )
   cPrgRet := strtran( cPrgRet, " *>" )
   cPrgRet := strtran( cPrgRet, "*>" )

   RETURN cPrgRet

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbide_paramCheckStrCpp( cType, nArg, cCast )

   HB_SYMBOL_UNUSED( cCast )

   SWITCH cType
   CASE "PB"
      RETURN "! HB_ISNIL( " + hb_ntos( nArg ) + " )"
   CASE "P"  //TODO
      RETURN "HB_ISPOINTER( " + hb_ntos( nArg ) + " )"
   CASE "O"
      RETURN "HB_ISOBJECT( " + hb_ntos( nArg ) + " )"
   CASE "CO"
      RETURN "( HB_ISOBJECT( " + hb_ntos( nArg ) + " ) || HB_ISCHAR( " + hb_ntos( nArg ) + " ) )"
   CASE "N*"
      RETURN  "HB_ISBYREF( " + hb_ntos( nArg ) + " )"
   CASE "N"
      RETURN  "HB_ISNUM( " + hb_ntos( nArg ) + " )"
   CASE "L*"
      RETURN  "HB_ISBYREF( " + hb_ntos( nArg ) + " )"
   CASE "L"
      RETURN  "HB_ISLOG( " + hb_ntos( nArg ) + " )"
   CASE "C"
      RETURN  "HB_ISCHAR( " + hb_ntos( nArg ) + " )"
   ENDSWITCH

   RETURN ""
/*----------------------------------------------------------------------*/

STATIC FUNCTION __TY_TYPEScpp( oM, nArgs )
   LOCAL i, s := ""
   FOR i := 1 TO nArgs
      s += hbide_paramCheckStrCpp( oM:hArgs[ i ]:cTypeHB, i, oM:hArgs[ i ]:cCast ) + " && "
   NEXT
   IF " && " $ s
      s := Left( s, len( s ) - 4 )
   ENDIF
   RETURN s

/*----------------------------------------------------------------------*/

METHOD HbQtSource:buildDOC()
   LOCAL cText, n, n1, n2, nLen, pWidget, cRet, cLib, i, cInherits

   LOCAL hEntry := { => }

   LOCAL cQT_VER := hb_ntos( hb_HexToNum( SubStr( ::cQtVer, 3, 2 ) ) ) + "." + hb_ntos( hb_HexToNum( SubStr( ::cQtVer, 5, 2 ) ) )

   hb_HKeepOrder( hEntry, .T. )

   n := ascan( ::cls_, {|e_| left( lower( e_[ 1 ] ), 7 ) $ "inherits" .and. !empty( e_[ 2 ] ) } )
   cInherits := iif( n > 0, ::cls_[ n, 2 ], "" )

   cLib := ::cQtModule

   hEntry[ "TEMPLATE"     ] := "Class"
   hEntry[ "NAME"         ] := ::cQtObject + "()"
   hEntry[ "CATEGORY"     ] := "Harbour Bindings for Qt"
   hEntry[ "SUBCATEGORY"  ] := "GUI"
   hEntry[ "EXTERNALLINK" ] := "http://doc.trolltech.com/" + cQT_VER + "/" + lower( ::cQtObject ) + ".html"
   hEntry[ "ONELINER"     ] := "Creates a new " + ::cQtObject + " object."
   hEntry[ "INHERITS"     ] := cInherits
   hEntry[ "SYNTAX"       ] := ::cQtObject + "( ... )" + hb_eol()
   hEntry[ "ARGUMENTS"    ] := ""
   hEntry[ "RETURNS"      ] := "An instance of the object of type " + ::cQtObject
   IF ! Empty( ::doc_ )
      hEntry[ "METHODS"      ] := ""
      nLen    := len( ::cQtObject )
      n       := at( ::cQtObject, ::doc_[ 1 ] )
      pWidget := "p" + ::cQtObject
      FOR i := 1 TO len( ::doc_ )
         IF !empty( cText := ::doc_[ i ] )
            cText := substr( cText, n + nLen + 1 )
            cText := strtran( cText, pWidget + ", " )
            cText := strtran( cText, pWidget )
            cText := strtran( cText, "(  )", "()" )
            n1    := at( "->", cText )
            cRet  := hbqtgen_prgRetNormalize( alltrim( substr( cText, n1 + 2 ) ) )
            cText := substr( cText, 1, n1 - 1 )
            n2    := max( 50, len( cText ) )
            cText := padR( cText, n2 )
            IF !empty( cRet )
               hEntry[ "METHODS" ] += ":" + cText + " -> " + cRet + hb_eol()
            ENDIF
         ENDIF
      NEXT
   ENDIF
   hEntry[ "DESCRIPTION"  ] := ""
   hEntry[ "EXAMPLES"     ] := ""
   FOR EACH cText IN ::docum_
      IF !empty( cText )
         hEntry[ "EXAMPLES" ] += cText + hb_eol()
      ENDIF
   NEXT
   hEntry[ "TESTS"        ] := ""
   hEntry[ "STATUS"       ] := "R"
   hEntry[ "COMPLIANCE"   ] := "Not Clipper compatible"
   hEntry[ "PLATFORMS"    ] := "Windows, Linux, Mac OS X, OS/2"
   hEntry[ "VERSION"      ] := cQT_VER + " or upper"
   hEntry[ "FILES"        ] := "Library: " + "hb" + cLib
#if 0
   hEntry[ "SEEALSO"      ] := ""
   hEntry[ "SEEALSO"      ] += iif( Empty( cInherits ), "", cInherits + "()" )
#endif

   RETURN hb_MemoWrit( ::cDOCFileName, __hbdoc_ToSource( { hEntry } ) )

/*----------------------------------------------------------------------*/

METHOD HbQtSource:parseVariables( cProto )
   LOCAL n, oMtd, oRet

   IF ( n := at( " ", cProto ) ) == 0
      RETURN .f.
   ENDIF

   oMtd := HbqtMethod():new()
   oMtd:cProto     := cProto
   oMtd:isVariable := .t.

   oMtd:cPre := cProto

   oMtd:cRet := alltrim( substr( cProto, 1, n - 1 ) )
   oMtd:cFun := alltrim( substr( cProto, n + 1    ) )

   oRet := HbqtArgument():new( oMtd:cRet, ::cQtObject, ::enum_, "const" $ oMtd:cPas, .t. )
   oMtd:oRet := oRet

   ::buildCppCode( oMtd )

   RETURN oMtd:lValid

/*----------------------------------------------------------------------*/

#define HBQTGEN_THIS_PROPER( s )   ( upper( left( s,1 ) ) + substr( s,2 ) )

METHOD HbQtSource:parseProto( cProto, fBody_ )
   LOCAL aArg, n, nn, cHBIdx, nIndex, s, ss, cFirstParamCast, cArg
   LOCAL oMtd, oRet, oArg, k, cKey, cVal
   LOCAL cRef
   LOCAL cHBIdxN := "1", sN := ""

   IF ( n := at( "(", cProto ) ) == 0
      RETURN .f.
   ENDIF
   IF ( nn := rat( ")", cProto ) ) == 0
      RETURN .f.
   ENDIF

   /*                    Method Parsing                    */
   oMtd := HbqtMethod():new()
   oMtd:cProto := cProto
   oMtd:fBody_ := fBody_

   oMtd:cPre := alltrim( substr( cProto,     1, n - 1      ) )
   oMtd:cPar := alltrim( substr( cProto, n + 1, nn - 1 - n ) )
   oMtd:cPas := alltrim( substr( cProto, nn + 1            ) )

   IF ( n := at( "[*", oMtd:cPas ) ) > 0
      IF ( nn := at( "*]", oMtd:cPas ) ) > 0
         oMtd:cMrk := alltrim( substr( oMtd:cPas, n + 2, nn - n - 2 ) )
         oMtd:cPas := alltrim( substr( oMtd:cPas, 1, n - 1 ) )
         FOR EACH k IN hb_aTokens( oMtd:cMrk, ";" )
            IF ( n := at( "=", k ) ) > 0
               cKey := alltrim( substr( k, 1, n - 1 ) )
               cVal := alltrim( substr( k, n + 1 ) )
               SWITCH upper( cKey )
               CASE "D"
                  oMtd:nDetach := val( cVal )
                  EXIT
               CASE "A"
                  oMtd:nAttach := val( cVal )
                  EXIT
               CASE "xxx"
                  EXIT
               ENDSWITCH
            ENDIF
         NEXT
      ENDIF
   ENDIF
   IF ( n := rat( " ", oMtd:cPre ) ) > 0
      oMtd:cFun := alltrim( substr( oMtd:cPre, n + 1    ) )
      oMtd:cRet := alltrim( substr( oMtd:cPre, 1, n - 1 ) )
   ELSE
      oMtd:cFun := oMtd:cPre
      oMtd:cRet := ""
   ENDIF
   IF empty( oMtd:cRet ) .AND. oMtd:cFun == ::cQtObject
      oMtd:isConstructor := .t.
      oMtd:cRet := oMtd:cFun
   ENDIF

   /*                 Return Value Parsing                   */
   oRet := HbqtArgument():new( oMtd:cRet, ::cQtObject, ::enum_, "const" $ oMtd:cPas, .t. )
   oMtd:oRet := oRet

   IF !empty( oMtd:cPar )
      /*                 Arguments Parsing                      */
      aArg := hb_ATokens( oMtd:cPar, "," )
      aeval( aArg, {| e, i | aArg[ i ] := alltrim( e ) } )

      FOR EACH cArg IN aArg
         nIndex := cArg:__enumIndex()

         oArg := HbqtArgument():new( cArg, ::cQtObject, ::enum_, .f., .f. )
         oMtd:hArgs[ nIndex ] := oArg

         oMtd:nHBIdx := nIndex // iif( oMtd:isConstructor, 0, 1 )
         oMtd:nHBIdxN := nIndex
         cHBIdx := hb_ntos( oMtd:nHBIdx )
         cHBIdxN := hb_ntos( nIndex )
         oMtd:cDocNM := HBQTGEN_THIS_PROPER( oArg:cName )

         oMtd:nArgs++
         oMtd:nArgsOpt += iif( oArg:lOptional, 1, 0 )

         IF empty( cFirstParamCast )
            cFirstParamCast := oArg:cCast
            IF "::" $ cFirstParamCast
               cFirstParamCast := substr( cFirstParamCast, at( "::", cFirstParamCast ) + 2 )
            ENDIF
         ENDIF

         cRef := NIL

         DO CASE
         CASE oArg:cCast == "..."
            oArg:cBody   := "..."
            oArg:cBodyN  := "..."
            oArg:cDoc    := "..."
            oArg:cTypeHB := "..."

         CASE oArg:cCast == "PHB_ITEM"
            oArg:cBody   := "hb_param( " + cHBIdx + ", HB_IT_ANY )"
            oArg:cBodyN  := "hb_param( " + cHBIdxN + ", HB_IT_ANY )"
            oArg:cDoc    := "x" + oMtd:cDocNM
            oArg:cTypeHB := "PB"

         CASE oArg:cCast == "T"
            oArg:cBody   := "hb_param( " + cHBIdx + ", HB_IT_ANY )"
            oArg:cBodyN  := "hb_param( " + cHBIdxN + ", HB_IT_ANY )"
            oArg:cDoc    := "x" + oMtd:cDocNM
            oArg:cTypeHB := "P"

         CASE oArg:cCast $ ::cInt .and. oArg:lFar
            aadd( oMtd:aPre, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdx, "i" + oMtd:cDocNM, "hb_storni" } )
            aadd( oMtd:aPreN, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdxN, "i" + oMtd:cDocNM, "hb_storni" } )
            oArg:cBody   := "&i" + oMtd:cDocNM
            oArg:cBodyN  := "&i" + oMtd:cDocNM
            oArg:cDoc    := "@n" + oMtd:cDocNM
            oArg:cTypeHB := "N*"

         CASE oArg:cCast $ ::cIntLong .and. oArg:lFar
            aadd( oMtd:aPre, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdx, "i" + oMtd:cDocNM, "hb_stornl" } )
            aadd( oMtd:aPreN, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdxN, "i" + oMtd:cDocNM, "hb_stornl" } )
            oArg:cBody   := "&i" + oMtd:cDocNM
            oArg:cBodyN  := "&i" + oMtd:cDocNM
            oArg:cDoc    := "@n" + oMtd:cDocNM
            oArg:cTypeHB := "N*"

         CASE oArg:cCast $ ::cIntLongLong .and. oArg:lFar
            aadd( oMtd:aPre, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdx, "i" + oMtd:cDocNM, "hb_stornint" } )
            aadd( oMtd:aPreN, { oArg:cCast + " i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdxN, "i" + oMtd:cDocNM, "hb_stornint" } )
            oArg:cBody   := "&i" + oMtd:cDocNM
            oArg:cBodyN  := "&i" + oMtd:cDocNM
            oArg:cDoc    := "@n" + oMtd:cDocNM
            oArg:cTypeHB := "N*"

         CASE oArg:cCast $ ::cInt
            IF !empty( oArg:cDefault ) .AND. !( oArg:cDefault == "0" )
               oArg:cBody := "hb_parnidef( " + cHBIdx + ", " + oArg:cDefault + " )"
               oArg:cBodyN := "hb_parnidef( " + cHBIdxN + ", " + oArg:cDefault + " )"
            ELSE
               oArg:cBody := "hb_parni( " + cHBIdx + " )"
               oArg:cBodyN := "hb_parni( " + cHBIdxN + " )"
            ENDIF
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast $ ::cIntLong
            IF !empty( oArg:cDefault ) .AND. !( oArg:cDefault == "0" )
               oArg:cBody := "hb_parnldef( " + cHBIdx + ", " + oArg:cDefault + " )"
               oArg:cBodyN := "hb_parnldef( " + cHBIdxN + ", " + oArg:cDefault + " )"
            ELSE
               oArg:cBody := "hb_parnl( " + cHBIdx + " )"
               oArg:cBodyN := "hb_parnl( " + cHBIdxN + " )"
            ENDIF
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast $ "qlonglong,qulonglong"
            IF !empty( oArg:cDefault ) .AND. !( oArg:cDefault == "0" )
               oArg:cBody := "( " + oArg:cCast + " ) hb_parnintdef( " + cHBIdx + ", " + oArg:cDefault + " )"
               oArg:cBodyN := "( " + oArg:cCast + " ) hb_parnintdef( " + cHBIdxN + ", " + oArg:cDefault + " )"
            ELSE
               oArg:cBody := "( " + oArg:cCast + " ) hb_parnint( " + cHBIdx + " )"
               oArg:cBodyN := "( " + oArg:cCast + " ) hb_parnint( " + cHBIdxN + " )"
            ENDIF
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast $ ::cIntLongLong
            IF !empty( oArg:cDefault ) .AND. !( oArg:cDefault == "0" )
               oArg:cBody := "hb_parnintdef( " + cHBIdx + ", " + oArg:cDefault + " )"
               oArg:cBodyN := "hb_parnintdef( " + cHBIdxN + ", " + oArg:cDefault + " )"
            ELSE
               oArg:cBody := "hb_parnint( " + cHBIdx + " )"
               oArg:cBodyN := "hb_parnint( " + cHBIdxN + " )"
            ENDIF
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast $ "double,qreal" .and. oArg:lFar
            aadd( oMtd:aPre, { "qreal qr" + oMtd:cDocNM + " = 0;", oMtd:nHBIdx, "qr" + oMtd:cDocNM, "hb_stornd"  } )
            aadd( oMtd:aPreN, { "qreal qr" + oMtd:cDocNM + " = 0;", oMtd:nHBIdxN, "qr" + oMtd:cDocNM, "hb_stornd"  } )
            oArg:cBody   := "&qr" + oMtd:cDocNM
            oArg:cBodyN  := "&qr" + oMtd:cDocNM
            oArg:cDoc    := "@n" + oMtd:cDocNM
            oArg:cTypeHB := "N*"

         CASE oArg:cCast $ "double,qreal,float"
            oArg:cBody   := "hb_parnd( " + cHBIdx + " )"
            oArg:cBodyN  := "hb_parnd( " + cHBIdxN + " )"
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast == "uchar" .and. oArg:lFar .and. ! oArg:lConst
            /* TOFIX: Such code is not valid and should never be generated (const->non-const) [vszakats] */
            oArg:cBody   := "( uchar * ) hb_parc( " + cHBIdx + " )"
            oArg:cDoc    := "c" + oMtd:cDocNM
            oArg:cTypeHB := "C"

         CASE oArg:cCast == "uchar" .and. oArg:lFar .and. oArg:lConst
            oArg:cBody   := "( const uchar * ) hb_parc( " + cHBIdx + " )"
            oArg:cBodyN  := "( uchar ) hb_parni( " + cHBIdxN + " )"
            oArg:cDoc    := "c" + oMtd:cDocNM
            oArg:cTypeHB := "C"

         CASE oArg:cCast == "uchar" .and. ! oArg:lFar .and. ! oArg:lConst
            oArg:cBody   := "( uchar ) hb_parni( " + cHBIdx + " )"
            oArg:cBodyN  := "( uchar ) hb_parni( " + cHBIdxN + " )"
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast == "char" .and. oArg:lFar .and. ! oArg:lConst
            /* TOFIX: Such code is not valid and should never be generated (const->non-const) [vszakats] */
            oArg:cBody   := "( char * ) hb_parc( " + cHBIdx + " )"
            oArg:cBodyN  := "( char * ) hb_parc( " + cHBIdxN + " )"
            oArg:cDoc    := "c" + oMtd:cDocNM
            oArg:cTypeHB := "C"

         CASE oArg:cCast == "char" .and. oArg:lFar .and. oArg:lConst
            oArg:cBody   := "( const char * ) hb_parc( " + cHBIdx + " )"
            oArg:cBodyN  := "( const char * ) hb_parc( " + cHBIdxN + " )"
            oArg:cDoc    := "c" + oMtd:cDocNM
            oArg:cTypeHB := "C"

         CASE oArg:cCast == "char" .and. ! oArg:lFar .and. ! oArg:lConst
            oArg:cBody   := "( char ) hb_parni( " + cHBIdx + " )"
            oArg:cBodyN  := "( char ) hb_parni( " + cHBIdxN + " )"
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE ( "::" $ oArg:cCast ) .and. oArg:lFar
            aadd( oMtd:aPre, { oArg:cCast + " i" + oMtd:cDocNM + " = ( " + oArg:cCast + " ) 0;", oMtd:nHBIdx, "i" + oMtd:cDocNM, "hb_storni" } )
            aadd( oMtd:aPreN, { oArg:cCast + " i" + oMtd:cDocNM + " = ( " + oArg:cCast + " ) 0;", oMtd:nHBIdxN, "i" + oMtd:cDocNM, "hb_storni" } )
            oArg:cBody   := "&i" + oMtd:cDocNM
            oArg:cBodyN  := "&i" + oMtd:cDocNM
            oArg:cDoc    := "@n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE ( "::" $ oArg:cCast )
            s := "( " + oArg:cCast + " ) hb_parni( " + cHBIdx + " )"
            sN := "( " + oArg:cCast + " ) hb_parni( " + cHBIdxN + " )"
            IF !empty( oArg:cDefault ) .AND. !( oArg:cDefault == "0" )
               IF ascan( ::enum_, oArg:cDefault ) > 0
                  ss := ::cQtObject + "::" + oArg:cDefault
               ELSE
                  ss := iif( "::" $ oArg:cDefault, oArg:cDefault, ;
                     iif( isDigit( left( oArg:cDefault, 1 ) ), oArg:cDefault, ::cQtObject + "::" + oArg:cDefault ) )
               ENDIF
               ss := "( " + oArg:cCast + " ) " + ss
               oArg:cBody := "( HB_ISNUM( " + cHBIdx + " ) ? " + s + " : " + ss + " )"
               oArg:cBodyN := "( HB_ISNUM( " + cHBIdxN + " ) ? " + sN + " : " + ss + " )"
            ELSE
               oArg:cBody := s
               oArg:cBodyN := sN
            ENDIF
            oArg:cDoc    := "n" + oMtd:cDocNM
            oArg:cTypeHB := "N"

         CASE oArg:cCast == "bool" .and. oArg:lFar
            aadd( oMtd:aPre, { "bool i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdx, "i" + oMtd:cDocNM, "hb_stornl" } )
            aadd( oMtd:aPreN, { "bool i" + oMtd:cDocNM + " = 0;", oMtd:nHBIdxN, "i" + oMtd:cDocNM, "hb_stornl" } )
            oArg:cBody   := "&i" + oMtd:cDocNM
            oArg:cBodyN  := "&i" + oMtd:cDocNM
            oArg:cDoc    := "@l" + oMtd:cDocNM
            oArg:cTypeHB := "L"

         CASE oArg:cCast == "bool"
            oArg:cBody   := "hb_parl( " + cHBIdx + " )"
            oArg:cBodyN  := "hb_parl( " + cHBIdxN + " )"
            oArg:cDoc    := "l" + oMtd:cDocNM
            oArg:cTypeHB := "L"

         CASE oArg:cCast == "QString"
            oArg:cBody   := "hb_parstr_utf8( " + cHBIdx + ", &pText%%%, NULL )"
            oArg:cBodyN  := "hb_parstr_utf8( " + cHBIdxN + ", &pText%%%, NULL )"
            oArg:cDoc    := "c" + oMtd:cDocNM  // oArg:cCast - W R O N G
            oArg:cTypeHB := "C"
#if 0
         CASE oArg:cCast == "FT_Face"
            oArg:cBody   := "hbqt_par_FT_Face( " + cHBIdx + " )"
            oArg:cBodyN  := "hbqt_par_FT_Face( " + cHBIdxN + " )"
            oArg:cDoc    := "c" + oMtd:cDocNM
            oArg:cTypeHB := "C"
#endif
         CASE oArg:cCast == "QIcon"
            cRef := "QIcon"
            s := "*hbqt_par_QIcon( " + cHBIdx + " )"
            sN := "*hbqt_par_QIcon( " + cHBIdxN + " )"
            oArg:cBody   := "( HB_ISCHAR( " + cHBIdx + " ) ? " + "QIcon( hbqt_par_QString( " + cHBIdx + " ) )" + " : " + s + ")"
            oArg:cBodyN  := "( HB_ISCHAR( " + cHBIdxN + " ) ? " + "QIcon( hbqt_par_QString( " + cHBIdxN + " ) )" + " : " + sN + ")"
            oArg:cDoc    := "co" + oArg:cCast //oMtd:cDocNM  // "p"
            oArg:cTypeHB := "CO" // "PCO"

         CASE oArg:lFar
            cRef := oArg:cCast
            oArg:cBody   := "hbqt_par_" + oArg:cCast + "( " + cHBIdx + " )"
            oArg:cBodyN  := "hbqt_par_" + oArg:cCast + "( " + cHBIdxN + " )"
            oArg:cDoc    := "o" + oArg:cCast //oMtd:cDocNM
            oArg:cTypeHB := "O" // "PO"

         CASE oArg:lAnd .AND. oArg:lConst
            cRef := oArg:cCast
            s := "*hbqt_par_" + oArg:cCast + "( " + cHBIdx + " )"
            sN := "*hbqt_par_" + oArg:cCast + "( " + cHBIdxN + " )"
            IF !empty( oArg:cDefault ) .and. ( "(" $ oArg:cDefault )
               oArg:cBody := "( HB_ISOBJECT( " + cHBIdx + " ) ? " + s + " : " + oArg:cDefault + " )"
               oArg:cBodyN := "( HB_ISOBJECT( " + cHBIdxN + " ) ? " + sN + " : " + oArg:cDefault + " )"
            ELSE
               oArg:cBody := s
               oArg:cBodyN := sN
            ENDIF
            oArg:cDoc    := "o" + oArg:cCast //oMtd:cDocNM
            oArg:cTypeHB := "O" //"PO"

         CASE oArg:lAnd
            cRef := oArg:cCast
            oArg:cBody   := "*hbqt_par_" + oArg:cCast + "( " + cHBIdx + " )"
            oArg:cBodyN  := "*hbqt_par_" + oArg:cCast + "( " + cHBIdxN + " )"
            oArg:cDoc    := "o" + oArg:cCast //oMtd:cDocNM //p
            oArg:cTypeHB := "O" //"PO"

         CASE oArg:cCast == "QChar"
            cRef := oArg:cCast
            oArg:cBody   := "*hbqt_par_" + oArg:cCast + "( " + cHBIdx + " )"
            oArg:cBodyN  := "*hbqt_par_" + oArg:cCast + "( " + cHBIdxN + " )"
            oArg:cDoc    := "o" + oArg:cCast //oMtd:cDocNM
            oArg:cTypeHB := "O" //"PO"

         OTHERWISE
            oArg:cBody   := ""   /* Just in case */
            oArg:cBodyN  := ""   /* Just in case */
            oArg:cDoc    := ""
            oArg:cTypeHB := ""

         ENDCASE

         hbqtgen_AddRef( ::hRef, cRef )

         oMtd:cParas += oArg:cBody + ", "
         oMtd:cParasN += oArg:cBodyN + ", "
         oMtd:cDocs  += oArg:cDoc + ", "
      NEXT
   ENDIF

   oMtd:nArgsReal := oMtd:nArgs - oMtd:nArgsOpt

   FOR EACH oArg IN oMtd:hArgs
      IF ( left( oArg:cCast, 1 ) == "Q" .OR. left( oArg:cCast, 3 ) == "HBQ" ) .AND. ;
                                            ! ( oArg:cCast $ "QString,QRgb" ) .AND. ;
                                            ! ( "::" $ oArg:cCast )
         oMtd:nArgQCast := oArg:__enumIndex()
         EXIT
      ENDIF
   NEXT
   FOR EACH oArg IN oMtd:hArgs
      IF oArg:cTypeHB $ "O"              // "PO"
         oMtd:nArgHBObj := oArg:__enumIndex()
         EXIT
      ENDIF
   NEXT

   IF right( oMtd:cParas, 2 ) == ", "
      oMtd:cParas := substr( oMtd:cParas, 1, len( oMtd:cParas ) - 2 )
      oMtd:cDocs  := substr( oMtd:cDocs , 1, len( oMtd:cDocs  ) - 2 )
   ENDIF
   IF right( oMtd:cParasN, 2 ) == ", "
      oMtd:cParasN := substr( oMtd:cParasN, 1, len( oMtd:cParasN ) - 2 )
   ENDIF

   ::buildCppCode( oMtd )

   HB_SYMBOL_UNUSED( cHBIdxN )
   HB_SYMBOL_UNUSED( sN )

   RETURN oMtd:lValid

/*----------------------------------------------------------------------*/

STATIC PROCEDURE hbqtgen_AddRef( hRef, cRef )

   IF ! Empty( cRef ) .AND. !( ">" $ cRef ) .AND. !( cRef $ "uchar|QString|QRgb|Bool|char" )
      hRef[ cRef ] := NIL
   ENDIF

   RETURN

/*----------------------------------------------------------------------*/

METHOD HbQtSource:buildCppCode( oMtd )
   LOCAL oRet   := oMtd:oRet
   LOCAL cPara  := oMtd:cParas
   LOCAL cParaN := oMtd:cParasN
   LOCAL cRef, cRefInList

   oMtd:cWdg      := "hbqt_par_" + ::cQtObject + "( 1 )->"
   oMtd:cParas    := iif( oMtd:isVariable(), "", "( " + oMtd:cParas + " )" )
   //oMtd:cParasN   := iif( oMtd:isVariable(), "", "( " + oMtd:cParasN + " )" )
   oMtd:cCmn      := oMtd:cWdg + oMtd:cFun + oMtd:cParas
   //oMtd:cCmnN     := "( _" + lower( substr( ::cQtObject, 2 ) ) + " )->" + oMtd:cFun + oMtd:cParasN
   oMtd:cDocNMRet := HBQTGEN_THIS_PROPER( oRet:cName )

   DO CASE
   CASE oMtd:isConstructor
      oMtd:cCmd := "hbqt_create_objectGC( hbqt_gcAllocate_" + ::cQtObject + "( new " + oRet:cCast + "( " + cPara + " ), true )" + ', "HB_' + upper(::cQtObject) +'")'
      oMtd:cCmdN := "hbqt_create_objectGC( hbqt_gcAllocate_" + ::cQtObject + "( new " + oRet:cCast + "( " + cParaN + " ), true )" + ', "HB_' + upper( ::cQtObject ) + '")'
      oMtd:cPrgRet := "o" + ::cQtObject  // "p"

   CASE "<" $ oRet:cCast
      DO CASE
      CASE ! ( "QList" $ oRet:cCast )
         oMtd:cCmd := ""
         oMtd:cCmdN := ""
         oMtd:cPrgRet := ""
      CASE "::" $ oRet:cCast
         oMtd:cCmd := ""
         oMtd:cCmdN := ""
         oMtd:cPrgRet := ""
      CASE "QPair" $ oRet:cCast
         oMtd:cCmd := ""
         oMtd:cCmdN := ""
         oMtd:cPrgRet := ""
      CASE "<T>" $ oRet:cCast
         oMtd:cCmd := ""
         oMtd:cCmdN := ""
         oMtd:cPrgRet := ""
      OTHERWISE
         cRef := "QList"
         cRefInList := strtran( oRet:cCast, "QList<" )
         cRefInList := strtran( cRefInList, ">" )
         cRefInList := strtran( cRefInList, "*" )
         cRefInList := strtran( cRefInList, " " )
         oMtd:isRetList := .t.
         oMtd:cCmd := "hbqt_create_objectGC( hbqt_gcAllocate_QList( new " + oRet:cCast + "( " + oMtd:cCmn + " ), true ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
         //oMtd:cCmdN := "hbqt_create_objectGC( hbqt_gcAllocate_QList( new " + oRet:cCast + "( " + oMtd:cCmnN + " ), true ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
         oMtd:cPrgRet := "o" + oMtd:cDocNMRet
      ENDCASE

   CASE oRet:cCast == "T"
      /* TOFIX: Such code is not valid and should never be generated [vszakats] */
      #if 1
      oMtd:cCmd := "hb_itemReturn( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_itemReturn( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet
      #else
      oMtd:cCmd := "hb_retptr( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retptr( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "p" + oMtd:cDocNMRet
      #endif

   CASE oRet:cCast == "void"
      oMtd:cCmd := oMtd:cCmn
      oMtd:cCmdN := oMtd:cCmnN
      oMtd:cPrgRet := "NIL"

   CASE oRet:cCast $ ::cInt
      oMtd:cCmd := "hb_retni( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retni( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "n" + oMtd:cDocNMRet

   CASE oRet:cCast $ ::cIntLong
      oMtd:cCmd := "hb_retnl( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retnl( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "n" + oMtd:cDocNMRet

   CASE oRet:cCast $ ::cIntLongLong
      oMtd:cCmd := "hb_retnint( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retnint( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "n" + oMtd:cDocNMRet

   CASE oRet:cCast $ "double,qreal,float"
      oMtd:cCmd := "hb_retnd( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retnd( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "n" + oMtd:cDocNMRet

   CASE "::" $ oRet:cCast
      oMtd:cCmd := "hb_retni( ( " + oRet:cCast + " ) " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retni( ( " + oRet:cCast + " ) " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "n" + oMtd:cDocNMRet

   CASE oRet:cCast == "bool"
      oMtd:cCmd := "hb_retl( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retl( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "l" + oMtd:cDocNMRet

   CASE oRet:cCast == "char" .AND. oRet:lFar
      oMtd:cCmd := "hb_retc( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retc( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "c" + oMtd:cDocNMRet

   CASE oRet:cCast == "char"
      oMtd:cCmd := "hb_retni( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retni( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "c" + oMtd:cDocNMRet

   CASE oRet:cCast == "QString"
      oMtd:cCmd := "hb_retstr_utf8( " + oMtd:cCmn + ".toUtf8().data()" + " )"
      oMtd:cCmdN := "hb_retstr_utf8( " + oMtd:cCmnN + ".toUtf8().data()" + " )"
      oMtd:cPrgRet := "c" + oMtd:cDocNMRet

   CASE oRet:cCast == "FT_Face"
      oMtd:cCmd := "hb_retc( " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retc( " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "c" + oMtd:cDocNMRet

   CASE oRet:lFar .AND. ( oRet:cCast $ "uchar" )
      oMtd:cCmd := "hb_retc( ( const char * ) " + oMtd:cCmn + " )"
      oMtd:cCmdN := "hb_retc( ( const char * ) " + oMtd:cCmnN + " )"
      oMtd:cPrgRet := "c" + oMtd:cDocNMRet //p

   CASE oRet:lFar .AND. ! oRet:lConst
      IF hbqtgen_isAqtObject( oRet:cCast )
         cRef := oRet:cCast
         oMtd:cCmd := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmn, .F. )
         oMtd:cCmdN := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmnN, .F. )
      ELSE
         /* TOFIX: Such code is not valid and should never be generated [vszakats] */
         oMtd:cCmd := "hb_retptr( ( " + oRet:cCast + "* ) " + oMtd:cCmn + " )"
         oMtd:cCmdN := "hb_retptr( ( " + oRet:cCast + "* ) " + oMtd:cCmnN + " )"
      ENDIF
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet

   CASE hbqtgen_isAqtObject( oRet:cCast )  .AND. ;
                             oRet:lFar     .AND. ;
                             oRet:lConst   .AND. ;
                             "Abstract" $ oRet:cCast
      cRef := oRet:cCast
      oMtd:cCmd := "hbqt_create_objectGC( hbqt_gcAllocate_" + oRet:cCast + "( ( void * ) " + oMtd:cCmn + ", false ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
      oMtd:cCmdN := "hbqt_create_objectGC( hbqt_gcAllocate_" + oRet:cCast + "( ( void * ) " + oMtd:cCmnN + ", false ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet  //p

   CASE hbqtgen_isAqtObject( oRet:cCast )  .AND. ;
                             oRet:lFar     .AND. ;
                             oRet:lConst   .AND. ;
                             oRet:lVirt
      cRef := oRet:cCast
      oMtd:cCmd := "hbqt_create_objectGC( hbqt_gcAllocate_" + oRet:cCast + "( ( void * ) " + oMtd:cCmn + ", false ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
      oMtd:cCmdN := "hbqt_create_objectGC( hbqt_gcAllocate_" + oRet:cCast + "( ( void * ) " + oMtd:cCmnN + ", false ) " + ', "HB_' + upper( ::cQtObject ) + '" )'
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet  //p

   CASE hbqtgen_isAqtObject( oRet:cCast )  .AND. ;
                             oRet:lFar     .AND. ;
                             oRet:lConst   .AND. ;
                             oRet:lConstL
      cRef := oRet:cCast
      oMtd:cCmd := hbqtgen_Get_Command_1( oRet:cCast, oMtd:cCmn )
      oMtd:cCmdN := hbqtgen_Get_Command_1( oRet:cCast, oMtd:cCmnN )
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet //p

   CASE oRet:lAnd .AND. oRet:lConst
      cRef := oRet:cCast
      oMtd:cCmd := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmn )
      oMtd:cCmdN := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmnN )
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet //p

   CASE oRet:lConst
      cRef := oRet:cCast
      oMtd:cCmd := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmn )
      oMtd:cCmdN := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmnN )
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet //p

   CASE oRet:lAnd
      cRef := oRet:cCast
      oMtd:cCmd := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmn )
      oMtd:cCmdN := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmnN )
      oMtd:cPrgRet := "o" + oMtd:cDocNMRet //p

   OTHERWISE
      /* No attribute is attached to return value */
      IF hbqtgen_isAqtObject( oRet:cCast )
         cRef := oRet:cCast
         oMtd:cCmd := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmn )
         oMtd:cCmdN := hbqtgen_Get_Command( oRet:cCast, oMtd:cCmnN )
         oMtd:cPrgRet := "o" + oMtd:cDocNMRet //p
      ELSE
         oMtd:cError := "<<< " + oMtd:cProto + " | " + oRet:cCast + " >>>"
         oMtd:cCmd := ""
         oMtd:cCmdN := ""
         oMtd:cPrgRet := ""
      ENDIF
   ENDCASE

   /* Lists to be disabled in parameters - TODO */
   IF "<" $ oMtd:cPar
      oMtd:cCmd := ""
      oMtd:cCmdN := ""
   ENDIF

   IF ( oMtd:lValid := ! Empty( oMtd:cCmd ) )
      aadd( ::aMethods, oMtd )
      hbqtgen_AddRef( ::hRef, cRef )
      IF ! empty( cRefInList ) .AND. ! ( cRefInList $ "int,qreal" )
         hbqtgen_AddRef( ::hRef, cRefInList )
      ENDIF
   ENDIF

   RETURN Self

/*----------------------------------------------------------------------*/
//                          Class HbqtMethod
/*----------------------------------------------------------------------*/

CREATE CLASS HbqtMethod

   DATA   name                                    INIT ""   //  widget
   DATA   isVariable                              INIT .f.
   DATA   lValid                                  INIT .t.
   DATA   nSiblings                               INIT 0    //  names post_fixed by number
   DATA   isSibling                               INIT .f.  //  is nother function with same name
   DATA   isConstructor                           INIT .f.
   DATA   areFuncClubbed                          INIT .t.
   DATA   isRetList                               INIT .f.

   DATA   cProto                                  INIT ""   //  QWidget * widget ( QWidget * parent, const QString & name ) const  [*D=4*]

   DATA   cPre                                    INIT ""   //  ^^^^^^^^^^^^^^^^
   DATA   cPar                                    INIT ""   //                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   DATA   cPas                                    INIT ""   //                                                              ^^^^^
   DATA   cMrk                                    INIT ""   //                                                                       ^^^

   DATA   nDetach                                 INIT 0
   DATA   nAttach                                 INIT 0

   DATA   cFun                                    INIT ""
   DATA   cRet                                    INIT ""

   DATA   cParas                                  INIT ""
   DATA   cParasN                                 INIT ""
   DATA   cDocs                                   INIT ""

   DATA   cDoc                                    INIT ""   // Qt_QWidget_setSize_1( nWidth, nHeight ) -> NIL

   DATA   cError                                  INIT ""
   DATA   cCmd                                    INIT ""
   DATA   cCmdN                                   INIT ""
   DATA   cCmn                                    INIT ""
   DATA   cCmnN                                   INIT ""
   DATA   cDocNM                                  INIT ""
   DATA   cDocNMRet                               INIT ""
   DATA   cPrgRet                                 INIT ""
   DATA   cWdg                                    INIT ""
   DATA   cHBFunc                                 INIT ""

   DATA   aPre                                    INIT {}
   DATA   aPreN                                   INIT {}
   DATA   nHBIdx
   DATA   nHBIdxN
   DATA   nArgQCast                               INIT 0    //  First argument position of type Q*Class
   DATA   nArgHBObj                               INIT 0    //  First argument position of type Q*Class

   DATA   oRet
   DATA   nArgs                                   INIT 0    //  Number of arguments contained
   DATA   nArgsOpt                                INIT 0    //  Number of optional arguments contained
   DATA   nArgsReal                               INIT 0    //  Number of minimum arguments to be supplied

   DATA   hArgs                                   INIT { => }

   DATA   fBody_                                  INIT {}

   DATA   cMtdDef
   DATA   cMtdCall

   METHOD new()

ENDCLASS

/*----------------------------------------------------------------------*/

METHOD HbqtMethod:new()
   hb_hKeepOrder( ::hArgs, .t. )
   RETURN Self

/*----------------------------------------------------------------------*/
//                         Class HbqtArgument
/*----------------------------------------------------------------------*/

CREATE CLASS HbqtArgument

   DATA   cRaw
   DATA   cNormal
   DATA   cName
   DATA   cCast                                INIT ""
   DATA   cBody
   DATA   cBodyN
   DATA   cDoc

   DATA   lRet                                 INIT .f.

   DATA   cTypeHb
   DATA   cTypeQt
   DATA   cObject

   DATA   lConst                               INIT .f.
   DATA   lAnd                                 INIT .f.
   DATA   lFar                                 INIT .f.
   DATA   lVirt                                INIT .f.
   DATA   lConstL                              INIT .f.

   DATA   lList                                INIT .f.

   DATA   lOptional                            INIT .f.
   DATA   cDefault

   METHOD new( cTxt, cQtObject, enum_, lConstL, lIsRetArg )

ENDCLASS

/*----------------------------------------------------------------------*/

METHOD HbqtArgument:new( cTxt, cQtObject, enum_, lConstL, lIsRetArg )
   LOCAL n

   ::cRaw    := cTxt
   ::lRet    := lIsRetArg
   ::lList   := "<" $ cTxt

   ::lConst  := "const"   $ cTxt
   ::lAnd    := "&"       $ cTxt
   ::lFar    := "*"       $ cTxt
   ::lVirt   := "virtual" $ cTxt
   ::lConstL := lConstL

   IF ( n := at( "=", cTxt ) ) > 0
      ::cDefault  := alltrim( substr( cTxt, n + 1 ) )
      ::lOptional := .t.
      cTxt := substr( cTxt, 1, n - 1 )
   ENDIF

   cTxt := strtran( cTxt, "virtual " )
   cTxt := strtran( cTxt, "const "   )
   cTxt := strtran( cTxt, "   "     , " " )
   cTxt := strtran( cTxt, "  "      , " " )
   IF ! ::lList
      cTxt := strtran( cTxt, "& " )
      cTxt := strtran( cTxt, "&"  )
      cTxt := strtran( cTxt, "* " )
      cTxt := strtran( cTxt, "*"  )
   ENDIF
   ::cNormal := cTxt := alltrim( cTxt )

   IF ::lList
      ::cCast := cTxt
      ::cName := ::cCast
   ELSE
      IF ( n := at( " ", cTxt ) ) > 0
         ::cCast := substr( cTxt, 1, n - 1 )
         ::cName := substr( cTxt, n + 1 )
      ELSE
         ::cCast := cTxt
         ::cName := cTxt
      ENDIF
   ENDIF

   IF ascan( enum_, {|e| iif( empty( e ), .f., e == ::cCast ) } ) > 0
      ::cCast := cQtObject + "::" + ::cCast
   ENDIF

   RETURN Self

/*----------------------------------------------------------------------*/
//                        Helper Functions
/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_Get_Command_1( cWgt, cCmn )
   RETURN "hbqt_create_objectGC( hbqt_gcAllocate_" + cWgt + "( new " + cWgt + "( *( " + cCmn + " ) ), true ) , " + '"HB_' + upper( cWgt ) +'")'

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_Get_Command( cWgt, cCmn, lNew )

   IF lNew == NIL
      lNew := .T.
   ENDIF

   IF lNew
      RETURN "hbqt_create_objectGC( hbqt_gcAllocate_" + cWgt + "( new " + cWgt + "( " + cCmn + " ), true ) , " + '"HB_' + upper( cWgt ) +'" )'
   ELSE
      RETURN "hbqt_create_objectGC( hbqt_gcAllocate_" + cWgt + "( " + cCmn + ", false ) , " + '"HB_' + upper( cWgt ) +'" )'
   ENDIF
   RETURN ""

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_PullOutSection( cQth, cSec )
   LOCAL cTxt, n, nn, cTknB, cTknE
   LOCAL a_:={}

   cTknB := "<" + cSec + ">"
   cTknE := "</" + cSec + ">"

   IF ( n := at( cTknB, cQth ) ) > 0
      IF( nn := at( cTknE, cQth ) ) > 0
         cTxt := substr( cQth, n + len( cTknB ), nn - 1 - ( n + len( cTknB ) ) )
      ENDIF
      IF !empty( cTxt )
         a_:= hb_ATokens( cTxt, Chr( 10 ) )
      ENDIF
   ENDIF

   RETURN a_

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_PullOutFuncBody( protos_, nFrom )
   LOCAL s, nTo := 0,  a_:= {}

   FOR EACH s IN protos_
      IF s:__enumIndex() > nFrom
         IF left( s, 1 ) == "}"
            nTo := s:__enumIndex()
            EXIT
         ENDIF
      ENDIF
   NEXT
   IF nTo > nFrom
      FOR EACH s IN protos_
         IF s:__enumIndex() > nFrom .AND. s:__enumIndex() < nTo
            aadd( a_, s )
            s := ""
         ENDIF
      NEXT
   ENDIF

   RETURN a_

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_isAqtObject( cCast )
   RETURN Left( cCast, 1 ) == "Q" .OR. Left( cCast, 3 ) == "HBQ"

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_CreateTarget( cFile, txt_ )
   LOCAL cContent := ""

   AEval( txt_, { |e| cContent += RTrim( e ) + hb_eol() } )

   RETURN hb_MemoWrit( cFile, cContent )

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_BuildCopyrightText( nMode, cQtVer )
   LOCAL txt_ := {}

   aadd( txt_, "/* WARNING: Automatically generated source file. DO NOT EDIT! */"              )
   aadd( txt_, ""                                                                              )
   aadd( txt_, "/* Harbour Project QT wrapper"                                                 )
   aadd( txt_, "   Copyright 2009-2011 Pritpal Bedi <bedipritpal@hotmail.com>"                 )
   aadd( txt_, "   www - http://harbour-project.org */"                                        )
   aadd( txt_, ""                                                                              )
   IF nMode == 0
   aadd( txt_, '#include "hbqt.h"'                                                             )
   aadd( txt_, '#include "hbapiitm.h"' )
   aadd( txt_, '#include "hbvm.h"' )
   aadd( txt_, '#include "hbapierr.h"' )
   aadd( txt_, '#include "hbstack.h"' )
   aadd( txt_, '#include "hbdefs.h"' )
   aadd( txt_, '#include "hbapicls.h"' )
   aadd( txt_, ""                                                                              )
   aadd( txt_, "#if QT_VERSION >= " + cQtVer                                                   )
   aadd( txt_, ""                                                                              )
   ENDIF

   RETURN txt_

/*----------------------------------------------------------------------*/

STATIC PROCEDURE hbqtgen_BuildFooter( txt_, cQtVer )

   aadd( txt_, "#endif /* #if QT_VERSION >= " + cQtVer + " */" )

   RETURN

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbqtgen_stripLastFrom( cStr, cDlm )
   LOCAL n
   IF ( n := rAt( cDlm, cStr ) ) > 0
      RETURN substr( cStr, 1, n - 1 )
   ENDIF
   RETURN cStr

/*----------------------------------------------------------------------*/
#if 0   /* KEEP AS IS - A Work in progress */
/*----------------------------------------------------------------------*/

STATIC FUNCTION hbide_pullSameMethods( cFun, aMethods, cQtObject )
   LOCAL i, oMtd, a_:={}, b_:={}, c_:={}, nArgs, n, txt_:={}
   LOCAL cSpc, cCrc, lFirst, nMtds, nTySame, lInIf

   FOR EACH oMtd IN aMethods
      IF oMtd:cFun == cFun
         aadd( a_, oMtd )
      ENDIF
   NEXT
   asort( a_, , , {|e,f| strzero( e:nArgs,2 ) + iif( e:nArgs == 0, "", e:hArgs[ 1 ]:cTypeHB ) > strzero( f:nArgs, 2 ) + iif( f:nArgs == 0, "", f:hArgs[ 1 ]:cTypeHB )  } )

   /* know the maximum groups by number of parameters - first CASE */
   aeval( a_, {|o| iif( ascan( b_, o:nArgs ) == 0, aadd( b_, o:nArgs ), NIL ) } )

   /* also take into account optional arguments if any */
   FOR EACH oMtd IN a_
      IF oMtd:nArgsReal < oMtd:nArgs
         FOR i := oMtd:nArgs - 1 TO oMtd:nArgsReal STEP -1
            IF ascan( b_, i ) == 0
               aadd( b_, i )
            ENDIF
         NEXT
      ENDIF
   NEXT

   /* Build the structure number of parameters wise */
   FOR EACH nArgs IN b_
      aadd( c_, { nArgs, {}, {}, {} } )
      n := len( c_ )
      FOR EACH oMtd IN a_
         IF oMtd:nArgs == nArgs
            aadd( c_[ n,2 ], oMtd )
         ENDIF
      NEXT
      /* Again append methods with optional arguments */
      FOR EACH oMtd IN a_
         IF oMtd:nArgsReal < oMtd:nArgs
            FOR i := oMtd:nArgs - 1 TO oMtd:nArgsReal STEP -1
               IF i == nArgs
                  aadd( c_[ n,2 ], oMtd )
               ENDIF
            NEXT
         ENDIF
      NEXT
   NEXT

   /* stack groups based on parameters descending */
   asort( c_, , , {|e,f| e[ 1 ] > f[ 1 ] } )

   /* again sort no of arguments based methods by type of arguments */
   FOR i := 10 TO 0 STEP -1  /* consider maximum 10 arguments */
      IF ( n := ascan( c_, {|e_| e_[ 1 ] == i } ) ) > 0
         a_:= c_[ n,2 ]
         asort( a_, , , {|e,f| __TY( e, c_[ n,1 ] ) < __TY( f, c_[ n,1 ] ) } )
      ENDIF
   NEXT

   cSpc := "   "
   aadd( txt_, cSpc + "SWITCH PCount()" )
   FOR EACH b_ IN c_
      n := b_[ 1 ]
      a_:= b_[ 2 ]
      aadd( txt_, cSpc + "CASE " + hb_ntos( n ) )      /* number of parameters */
      cCrc    := "xxx"
      nMtds   := 0
      lInIf   := .f.
      nTySame := 0
      IF n > 0
         lFirst := .t.
         aadd( txt_, cSpc + cSpc + "DO CASE" )               /* type of parameters   */
      ENDIF
      FOR EACH oMtd IN a_
         IF n > 0
            IF cCrc != __TY( oMtd, n )
               cCrc    := __TY( oMtd, n )
               nMtds   := 0
               nTySame := 0
               aeval( a_, {|o| iif( __TY( o,n ) == cCrc, nTySame++, NIL ) } )
               lInIf   := oMtd:nArgQCast > 0 .AND. oMtd:nArgQCast <= n .AND. nTySame > 1
               IF ! lFirst
                  lFirst := .t.
                  aadd( txt_, cSpc + cSpc + "ENDCASE" )
               ENDIF
               aadd( txt_, cSpc + cSpc + "CASE " + __TY_TYPES( oMtd,n ) )
            ENDIF
         ENDIF
         nMtds++
         hbide_addReturnMethod( txt_, oMtd, cQtObject, iif( n == 0, 6, 9 ), nMtds, .t., lInIf, nTySame, n )
      NEXT
      IF n > 0
         aadd( txt_, cSpc + cSpc + "ENDCASE" )
         aadd( txt_, cSpc + cSpc + "EXIT" )
      ENDIF
   NEXT
   aadd( txt_, cSpc + "ENDSWITCH" )

   RETURN txt_

/*----------------------------------------------------------------------*/

STATIC FUNCTION __TY_TYPES( oM, nArgs )
   LOCAL i, s := ""
   FOR i := 1 TO nArgs
      s += hbide_paramCheckStr( oM:hArgs[ i ]:cTypeHB, i ) + " .AND. "
   NEXT
   IF " .AND. " $ s
      s := substr( s, 1, len( s ) - 7 )
   ENDIF
   RETURN s

/*----------------------------------------------------------------------*/

STATIC FUNCTION __TY( oM, nArgs )
   LOCAL i, s := ""
   FOR i := 1 TO nArgs
      s += PadR( oM:hArgs[ i ]:cTypeHB, 3 )
   NEXT
   RETURN s

/*----------------------------------------------------------------------*/

STATIC FUNCTION hbide_paramCheckStr( cType, nArg )

   SWITCH cType
   CASE "PB"
      RETURN "( " + " hb_pvalue( " + hb_ntos( nArg ) + " )" + " != NIL )"
   CASE "P"
      RETURN "hb_isPointer( hb_pvalue( " + hb_ntos( nArg ) + " ) )"
   CASE "O"
      RETURN "hb_isObject( hb_pvalue( " + hb_ntos( nArg ) + " ) )"
   CASE "CO"
      RETURN "( hb_isObject( hb_pvalue( " + hb_ntos( nArg ) + " ) ) .OR. hb_isChar( hb_pvalue( " + hb_ntos( nArg ) + " ) ) )"
   CASE "N"
      RETURN  "hb_isNumeric( hb_pvalue( " + hb_ntos( nArg ) + " ) )"
   CASE "L"
      RETURN  "hb_isLogical( hb_pvalue( " + hb_ntos( nArg ) + " ) )"
   CASE "C"
      RETURN  "hb_isChar( hb_pvalue( " + hb_ntos( nArg ) + " ) )"
   ENDSWITCH
   RETURN ""

/*----------------------------------------------------------------------*/
#endif
/*----------------------------------------------------------------------*/


